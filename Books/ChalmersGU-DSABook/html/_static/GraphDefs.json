{"concepts": {"2-3 tree": "node has either 2 children or 3 children.\nKey values are ordered to maintain the\n<a class=\"reference internal\" href=\"#term-binary-search-tree-property\"><span class=\"xref std std-term\">binary search tree property</span></a>.\nThe 2-3 tree is always height balanced, and its insert, search,\nand remove operations all have <span class=\"math notranslate nohighlight\">\\(\\Theta(\\log n)\\)</span> cost.</p>\n</dd>", "binary search tree property": "<a class=\"reference internal\" href=\"#term-node\"><span class=\"xref std std-term\">nodes</span></a> in a <a class=\"reference internal\" href=\"#term-bst\"><span class=\"xref std std-term\">BST</span></a>.\nAll nodes stored in the left subtree of a node whose key value\nis <span class=\"math notranslate nohighlight\">\\(K\\)</span> have key values less than or equal to <span class=\"math notranslate nohighlight\">\\(K\\)</span>.\nAll nodes stored in the right subtree of a node whose key value\nis <span class=\"math notranslate nohighlight\">\\(K\\)</span> have key values greater than <span class=\"math notranslate nohighlight\">\\(K\\)</span>.</p>\n</dd>", "B-tree": "A B-tree is a <a class=\"reference internal\" href=\"#term-balanced-tree\"><span class=\"xref std std-term\">balanced tree</span></a> that typically has high\nbranching factor (commonly as much as 100\n<a class=\"reference internal\" href=\"#term-child\"><span class=\"xref std std-term\">children</span></a> per <a class=\"reference internal\" href=\"#term-internal-node\"><span class=\"xref std std-term\">internal node</span></a>),\ncausing the tree to be very shallow.\nWhen stored on disk, the node size is selected to be same as the\ndesired unit of I/O (so some multiple of the disk <a class=\"reference internal\" href=\"#term-sector\"><span class=\"xref std std-term\">sector</span></a>\nsize).\nThis makes it easy to gain access to the record associated with\na given <a class=\"reference internal\" href=\"#term-search-key\"><span class=\"xref std std-term\">search key</span></a> stored in the tree with few\n<a class=\"reference internal\" href=\"#term-disk-access\"><span class=\"xref std std-term\">disk accesses</span></a>.\nThe most commonly implemented variant of the B-tree is the\n<a class=\"reference internal\" href=\"#term-b-tree\"><span class=\"xref std std-term\">B$^+$-tree</span></a>.</p>\n</dd>", "abstract data type": "within some language, independent of an implementation.\nThe <a class=\"reference internal\" href=\"#term-interface\"><span class=\"xref std std-term\">interface</span></a> for the ADT is defined in terms of a <a class=\"reference internal\" href=\"#term-type\"><span class=\"xref std std-term\">type</span></a>\nand a set of operations on that type.\nThe behavior of each operation is determined by its inputs and\noutputs.\nAn ADT does not specify <em>how</em> the data type is implemented.\nThese implementation details are hidden from the user of the ADT\nand protected from outside access, a concept referred to as\n<a class=\"reference internal\" href=\"#term-encapsulation\"><span class=\"xref std std-term\">encapsulation</span></a>.</p>\n</dd>", "ADT": "</dd>", "interface": "signatures and fields. An interface does not contain an implementation\nof the methods or any <a class=\"reference internal\" href=\"#term-data-member\"><span class=\"xref std std-term\">data members</span></a>.</p>\n</dd>", "activation record": "program execution.\nIt stores any active <a class=\"reference internal\" href=\"#term-local-variable\"><span class=\"xref std std-term\">local variable</span></a> and the return\naddress from which a new subroutine is being called, so that\nthis information can be recovered when the subroutine\nterminates.</p>\n</dd>", "local variable": "It exists only from the time when the function is called to when\nthe function exits.\nWhen a function is suspended (due to calling another function),\nthe function\u2019s local variables are stored in an\n<a class=\"reference internal\" href=\"#term-activation-record\"><span class=\"xref std std-term\">activation record</span></a> on the <a class=\"reference internal\" href=\"#term-runtime-stack\"><span class=\"xref std std-term\">runtime stack</span></a>.</p>\n</dd>", "acyclic graph": "<a class=\"reference internal\" href=\"#term-cycle\"><span class=\"xref std std-term\">cycles</span></a>.</p>\n</dd>", "directed acyclic graph": "Abbreviated as <a class=\"reference internal\" href=\"#term-dag\"><span class=\"xref std std-term\">DAG</span></a>.\nNote that a DAG is not necessarily a <a class=\"reference internal\" href=\"#term-tree\"><span class=\"xref std std-term\">tree</span></a> since a given\n<a class=\"reference internal\" href=\"#term-node\"><span class=\"xref std std-term\">node</span></a> might have multiple <a class=\"reference internal\" href=\"#term-parent\"><span class=\"xref std std-term\">parents</span></a>.</p>\n</dd>", "cycles <cycle>": "", "aggregate type": "For example, a typical database record.\nAnother term for this is <a class=\"reference internal\" href=\"#term-composite-type\"><span class=\"xref std std-term\">composite type</span></a>.</p>\n</dd>", "composite type": "For example, a typical database record.\nAnother term for this is <a class=\"reference internal\" href=\"#term-aggregate-type\"><span class=\"xref std std-term\">aggregate type</span></a>.</p>\n</dd>", "member": "In abstract design, a <a class=\"reference internal\" href=\"#term-data-item\"><span class=\"xref std std-term\">data item</span></a> is a member of a <a class=\"reference internal\" href=\"#term-type\"><span class=\"xref std std-term\">type</span></a>.\nIn an object-oriented language,\n<a class=\"reference internal\" href=\"#term-data-member\"><span class=\"xref std std-term\">data members</span></a> are data fields in an\nobject.</p>\n</dd>", "algorithm": "</dd>", "problem": "It is best thought of as a <a class=\"reference internal\" href=\"#term-function\"><span class=\"xref std std-term\">function</span></a> or a mapping of\ninputs to outputs.</p>\n</dd>", "program": "programming language.</p>\n</dd>", "algorithm analysis": "<a class=\"reference internal\" href=\"#term-asymptotic-algorithm-analysis\"><span class=\"xref std std-term\">asymptotic algorithm analysis</span></a>, generally used as a\nsynonym for <a class=\"reference internal\" href=\"#term-asymptotic-analysis\"><span class=\"xref std std-term\">asymptotic analysis</span></a>.</p>\n</dd>", "growth rate": "of the <a class=\"reference internal\" href=\"#term-algorithm\"><span class=\"xref std std-term\">algorithm</span></a> grows as the size of its input grows.</p>\n</dd>", "upper bound": "always greater than or equal to the growth rate of the\n<a class=\"reference internal\" href=\"#term-algorithm\"><span class=\"xref std std-term\">algorithm</span></a> in question.\nIn practice, this is the slowest-growing function that we know\ngrows at least as fast as all but a constant number of inputs.\nIt could be a gross over-estimate of the truth.\nSince the upper bound for the algorithm can be very different\nfor different situations (such as the <a class=\"reference internal\" href=\"#term-best-case\"><span class=\"xref std std-term\">best case</span></a> or\n<a class=\"reference internal\" href=\"#term-worst-case\"><span class=\"xref std std-term\">worst case</span></a>), we typically have to specify which\nsituation we are referring to.</p>\n</dd>", "lower bound": "always less than or equal to the growth rate of the\n<a class=\"reference internal\" href=\"#term-algorithm\"><span class=\"xref std std-term\">algorithm</span></a> in question.\nIn practice, this is the fastest-growing function that we know\ngrows no faster than all but a constant number of inputs.\nIt could be a gross under-estimate of the truth.\nSince the lower bound for the algorithm can be very different\nfor different situations (such as the <a class=\"reference internal\" href=\"#term-best-case\"><span class=\"xref std std-term\">best case</span></a> or\n<a class=\"reference internal\" href=\"#term-worst-case\"><span class=\"xref std std-term\">worst case</span></a>), we typically have to specify which\nsituation we are referring to.</p>\n</dd>", "asymptotic analysis": "computer program by identifying its <a class=\"reference internal\" href=\"#term-growth-rate\"><span class=\"xref std std-term\">growth rate</span></a>.\nAsymptotic analysis also gives a way to\ndefine the inherent difficulty of a <a class=\"reference internal\" href=\"#term-problem\"><span class=\"xref std std-term\">problem</span></a>.\nWe frequently use the term <a class=\"reference internal\" href=\"#term-algorithm-analysis\"><span class=\"xref std std-term\">algorithm analysis</span></a> to mean\nthe same thing.</p>\n</dd>", "asymptotic algorithm analysis": "</dd>", "all-pairs shortest paths problem": "distances on the <a class=\"reference internal\" href=\"#term-edge\"><span class=\"xref std std-term\">edges</span></a>,\nfind the shortest paths between every pair of\nvertices in the graph.\nOne approach to solving this problem is\n<a class=\"reference internal\" href=\"#term-floyd-s-algorithm\"><span class=\"xref std std-term\">Floyd\u2019s algorithm</span></a>, which uses the\n<a class=\"reference internal\" href=\"#term-dynamic-programming\"><span class=\"xref std std-term\">dynamic programming</span></a> algorithmic technique.</p>\n</dd>", "Floyd's algorithm": "", "amortized analysis": "cost for a series of operations and amortizes this total cost\nover the full series.\nThis is as opposed to considering every individual operation to\nindependently have the <a class=\"reference internal\" href=\"#term-worst-case\"><span class=\"xref std std-term\">worst case</span></a> cost, which might lead\nto an overestimate for the total cost of the series.</p>\n</dd>", "amortized cost": "<a class=\"reference internal\" href=\"#term-amortized-analysis\"><span class=\"xref std std-term\">amortized analysis</span></a>.</p>\n</dd>", "array-based list": "store the list elements. Typical implementations fix the array\nsize at creation of the list, and the <a class=\"reference internal\" href=\"#term-overhead\"><span class=\"xref std std-term\">overhead</span></a>\nis the number of array positions that are presently unused.</p>\n</dd>", "array": "locations and refers to them by an index.</p>\n</dd>", "array-based stack": "store the elements when implementing the <a class=\"reference internal\" href=\"#term-stack\"><span class=\"xref std std-term\">stack</span></a> ADT.</p>\n</dd>", "stack": "removed from only one end.</p>\n</dd>", "array-based queue": "store the elements when implementing the <a class=\"reference internal\" href=\"#term-queue\"><span class=\"xref std std-term\">queue</span></a> ADT.</p>\n</dd>", "queue": "end, and removed only from the other one end.</p>\n</dd>", "assembly code": "is easy to convert into the final form that the computer can\nexecute.\nAn assembly language is typically a direct mapping of one or a\nfew instructions that the CPU can execute into a mnemonic form\nthat is relatively easy for a human to read.</p>\n</dd>", "intermediate code": "original high-level language into a form on which it is easier\nto do other stages of the process.\nFor example, some compilers will transform the original\nhigh-level source code into <a class=\"reference internal\" href=\"#term-assembly-code\"><span class=\"xref std std-term\">assembly code</span></a> on which it\ncan do <a class=\"reference internal\" href=\"#term-code-optimization\"><span class=\"xref std std-term\">code optimization</span></a>, before translating it into its final\nexecutable form.</p>\n</dd>", "AVL Tree": "the standard BST in that it uses modified insert and remove\nmethods in order to keep the tree\n<a class=\"reference internal\" href=\"#term-balanced-tree\"><span class=\"xref std std-term\">balanced</span></a>.\nSimilar to a <a class=\"reference internal\" href=\"#term-splay-tree\"><span class=\"xref std std-term\">Splay Tree</span></a> in that it uses the concept of\n<a class=\"reference internal\" href=\"#term-rotation\"><span class=\"xref std std-term\">rotations</span></a> in the insert and remove operations.</p>\n</dd>", "double rotation": "<a class=\"reference internal\" href=\"#term-splay-tree\"><span class=\"xref std std-term\">Splay Tree</span></a> and <a class=\"reference internal\" href=\"#term-avl-tree\"><span class=\"xref std std-term\">AVL Tree</span></a>.</p>\n</dd>", "single rotation": "<a class=\"reference internal\" href=\"#term-splay-tree\"><span class=\"xref std std-term\">Splay Tree</span></a> and <a class=\"reference internal\" href=\"#term-avl-tree\"><span class=\"xref std std-term\">AVL Tree</span></a>.</p>\n</dd>", "balanced tree": "criteria for being balanced.\nTwo possibilities are that the tree is\n<a class=\"reference internal\" href=\"#term-height-balanced\"><span class=\"xref std std-term\">height balanced</span></a>, or that the tree has a roughly equal\nnumber of <a class=\"reference internal\" href=\"#term-node\"><span class=\"xref std std-term\">nodes</span></a> in each subtree.</p>\n</dd>", "B$^+$-tree": "A B$^+$-tree does not store data at the\n<a class=\"reference internal\" href=\"#term-internal-node\"><span class=\"xref std std-term\">internal nodes</span></a>, but\ninstead only stores <a class=\"reference internal\" href=\"#term-search-key\"><span class=\"xref std std-term\">search key</span></a> values as direction\nfinders for the purpose of searching through the tree.\nOnly the <a class=\"reference internal\" href=\"#term-leaf-node\"><span class=\"xref std std-term\">leaf nodes</span></a> store a\n<a class=\"reference internal\" href=\"#term-reference\"><span class=\"xref std std-term\">reference</span></a> to the actual data records.</p>\n</dd>", "B$^*$-tree": "The <span class=\"math notranslate nohighlight\">\\(\\mathrm{B}^*\\)</span> tree is identical to the <span class=\"math notranslate nohighlight\">\\(\\mathrm{B}^+\\)</span>\ntree, except for the rules used to split and merge nodes.\nInstead of splitting a node in half when it overflows, the\n<span class=\"math notranslate nohighlight\">\\(\\mathrm{B}^*\\)</span> tree\ngives some records to its neighboring sibling, if possible.\nIf the sibling is also full, then these two nodes split into three.\nSimilarly, when a node underflows, it is combined with its two\nsiblings, and the total reduced to two nodes.\nThus, the nodes are always at least two thirds full.</p>\n</dd>", "bad reference": "but not initialized.</p>\n</dd>", "NullPointerException": "", "bag": "(like a set), but which allows for duplicate-valued elements\n(unlike a set).</p>\n</dd>", "multilist": "This term is sometimes used as a synonym to the term\n<a class=\"reference internal\" href=\"#term-bag\"><span class=\"xref std std-term\">bag</span></a>.</p>\n</dd>", "binary search tree": "values: The <a class=\"reference internal\" href=\"#term-search-key\"><span class=\"xref std std-term\">search key</span></a> value for any node <span class=\"math notranslate nohighlight\">\\(A\\)</span> must\nbe greater than the (key) values for all nodes in the left\n<a class=\"reference internal\" href=\"#term-subtree\"><span class=\"xref std std-term\">subtree</span></a> of <span class=\"math notranslate nohighlight\">\\(A\\)</span>, and less than the key values for\nall nodes in the right subtree of <span class=\"math notranslate nohighlight\">\\(A\\)</span>.\nSome convention must be adopted if\nmultiple nodes with the same key value are permitted,\ntypically these are required to be in the right subtree.</p>\n</dd>", "AVL tree": "", "BST": "</dd>", "splay tree": "", "binary tree": "node together two binary trees, called the left and right\n<a class=\"reference internal\" href=\"#term-subtree\"><span class=\"xref std std-term\">subtrees</span></a>, which are <a class=\"reference internal\" href=\"#term-disjoint\"><span class=\"xref std std-term\">disjoint</span></a> from each\nother and from the <a class=\"reference internal\" href=\"#term-root\"><span class=\"xref std std-term\">root</span></a>.</p>\n</dd>", "binary trie": "Generally this is an implementation for a <a class=\"reference internal\" href=\"#term-search-tree\"><span class=\"xref std std-term\">search tree</span></a>.\nThis means that the <a class=\"reference internal\" href=\"#term-search-key\"><span class=\"xref std std-term\">search key</span></a> values are thought of a\nbinary digits, with the digit in the position corresponding to\nthis a node\u2019s <a class=\"reference internal\" href=\"#term-level\"><span class=\"xref std std-term\">level</span></a> in the tree indicating a left branch\nif it is \u201c0\u201d, or a right branch if it is \u201c1\u201d.\nExamples include the <a class=\"reference internal\" href=\"#term-huffman-coding-tree\"><span class=\"xref std std-term\">Huffman coding tree</span></a> and the\n<a class=\"reference internal\" href=\"#term-bintree\"><span class=\"xref std std-term\">Bintree</span></a>.</p>\n</dd>", "complete binary tree": "bottom row filled in left to right.\nDue to this requirement, there is only one tree of <span class=\"math notranslate nohighlight\">\\(n\\)</span>\nnodes for any value of <span class=\"math notranslate nohighlight\">\\(n\\)</span>.\nSince storing the records in an <a class=\"reference internal\" href=\"#term-array\"><span class=\"xref std std-term\">array</span></a> in row order leads to a\nsimple mapping from a node\u2019s position in the array to its\n<a class=\"reference internal\" href=\"#term-parent\"><span class=\"xref std std-term\">parent</span></a>, <a class=\"reference internal\" href=\"#term-sibling\"><span class=\"xref std std-term\">siblings</span></a>, and\n<a class=\"reference internal\" href=\"#term-child\"><span class=\"xref std std-term\">children</span></a>, the array representation is most\ncommonly used to implement the complete binary tree.\nThe <a class=\"reference internal\" href=\"#term-heap\"><span class=\"xref std std-term\">heap</span></a> data structure is a complete binary tree with\npartial ordering constraints on the node values.</p>\n</dd>", "bintree": "<a class=\"reference internal\" href=\"#term-trie\"><span class=\"xref std std-term\">trie</span></a>, typically used to store point data in two or more\ndimensions.\nSimilar to a <a class=\"reference internal\" href=\"#term-pr-quadtree\"><span class=\"xref std std-term\">PR quadtree</span></a> except that at each level, it\nsplits one dimension in half.\nSince many leaf nodes of the PR quadtree will contain no data\npoints, implementation often makes use of the <a class=\"reference internal\" href=\"#term-flyweight\"><span class=\"xref std std-term\">flyweight</span></a>\n<a class=\"reference internal\" href=\"#term-design-pattern\"><span class=\"xref std std-term\">design pattern</span></a>.</p>\n</dd>", "flyweight": "problem:\nYou have an application with many objects.\nSome of these objects are identical in the information that\nthey contain, and the role that they play.\nBut they must be reached from various places, and conceptually they\nreally are distinct objects.\nBecause there is so much duplication of the same information,\nwe want to reduce memory cost by sharing that space.\nFor example, in document layout,\nthe letter \u201cC\u201d might be represented by an object that\ndescribes that character\u2019s strokes and bounding box.\nHowever, we do not want to create a separate \u201cC\u201d object everywhere\nin the document that a \u201cC\u201d appears.\nThe solution is to allocate a single copy of the shared representation\nfor \u201cC\u201d objects.\nThen, every place in the document that needs a \u201cC\u201d in a given font,\nsize, and typeface will reference this single copy.\nThe various instances of <a class=\"reference internal\" href=\"#term-reference\"><span class=\"xref std std-term\">references</span></a> to a\nspecific form of \u201cC\u201d are called flyweights.\nFlyweights can also be used to implement the empty leaf nodes\nof the <a class=\"reference internal\" href=\"#term-bintree\"><span class=\"xref std std-term\">bintree</span></a> and <a class=\"reference internal\" href=\"#term-pr-quadtree\"><span class=\"xref std std-term\">PR quadtree</span></a>.</p>\n</dd>", "breadth-first search": "As the name implies, all immediate <a class=\"reference internal\" href=\"#term-neighbor\"><span class=\"xref std std-term\">neighbors</span></a>\nfor a <a class=\"reference internal\" href=\"#term-node\"><span class=\"xref std std-term\">node</span></a> are <a class=\"reference internal\" href=\"#term-visit\"><span class=\"xref std std-term\">visited</span></a> before any\nmore-distant nodes are visited.\nBFS is driven by a <a class=\"reference internal\" href=\"#term-queue\"><span class=\"xref std std-term\">queue</span></a>.\nA start vertex is placed on the queue.\nThen, until the queue is empty, a node is taken off the\nqueue, visited, and and then any <a class=\"reference internal\" href=\"#term-unvisited\"><span class=\"xref std std-term\">unvisited</span></a> neighbors are\nplaced onto the queue.</p>\n</dd>", "BFS": "</dd>", "bubble sort": "<a class=\"reference internal\" href=\"#term-best-case\"><span class=\"xref std std-term\">best</span></a>, <a class=\"reference internal\" href=\"#term-average-case\"><span class=\"xref std std-term\">average</span></a>,\nand <a class=\"reference internal\" href=\"#term-worst-case\"><span class=\"xref std std-term\">worst</span></a> cases.\nEven an optimized version will normally run slower than\n<a class=\"reference internal\" href=\"#term-insertion-sort\"><span class=\"xref std std-term\">insertion sort</span></a>, so it has little to recommend it.</p>\n</dd>", "bucket hashing": "of the <a class=\"reference internal\" href=\"#term-hash-table\"><span class=\"xref std std-term\">hash table</span></a> are grouped together to form a\n<a class=\"reference internal\" href=\"#term-bucket\"><span class=\"xref std std-term\">bucket</span></a>.\nThe <a class=\"reference internal\" href=\"#term-hash-function\"><span class=\"xref std std-term\">hash function</span></a> then either hashes to some bucket, or\nelse it hashes to a <a class=\"reference internal\" href=\"#term-home-slot\"><span class=\"xref std std-term\">home slot</span></a> in the normal way, but\nthis home slot is part of some bucket.\n<a class=\"reference internal\" href=\"#term-collision-resolution\"><span class=\"xref std std-term\">Collision resolution</span></a> is handled\nfirst by attempting to find a free position within the same\nbucket as the home slot.\nIf the bucket if full, then the record is placed in an\n<a class=\"reference internal\" href=\"#term-overflow-bucket\"><span class=\"xref std std-term\">overflow bucket</span></a>.</p>\n</dd>", "bucket": "<a class=\"reference internal\" href=\"#term-slot\"><span class=\"xref std std-term\">slots</span></a> in the <a class=\"reference internal\" href=\"#term-hash-table\"><span class=\"xref std std-term\">hash table</span></a> that are grouped\ntogether.</p>\n</dd>", "buffer": "The size of a buffer is typically one or a multiple of the basic\nunit of I/O that is read or written on each access to\n<a class=\"reference internal\" href=\"#term-secondary-storage\"><span class=\"xref std std-term\">secondary storage</span></a> such as a <a class=\"reference internal\" href=\"#term-disk-drive\"><span class=\"xref std std-term\">disk drive</span></a>.</p>\n</dd>", "dirty bit": "with each <a class=\"reference internal\" href=\"#term-buffer\"><span class=\"xref std std-term\">buffer</span></a> that indicates whether the contents of\nthe buffer have changed since being read in from\n<a class=\"reference internal\" href=\"#term-backing-storage\"><span class=\"xref std std-term\">backing storage</span></a>.\nWhen the buffer is <a class=\"reference internal\" href=\"#term-2\"><span class=\"xref std std-term\">flushed</span></a> from the buffer pool,\nthe buffer\u2019s contents must be written to the backing storage if\nthe dirty bit is set (that is, if the contents have changed).\nThis means that a relatively expensive write operation is\nrequired.\nIn contrast, if the dirty bit is not set, then it is unnecessary\nto write the contents to backing storage, thus saving time over\nnot keeping track of whether the contents have changed or not.</p>\n</dd>", "buffer pool": "The buffer pool is an example of a <a class=\"reference internal\" href=\"#term-caching\"><span class=\"xref std std-term\">cache</span></a>.\nIt is stored in <a class=\"reference internal\" href=\"#term-primary-storage\"><span class=\"xref std std-term\">primary storage</span></a>, and holds data that is\nexpected to be used in the near future.\nWhen a data value is requested, the buffer pool is searched\nfirst.\nIf the value is found in the buffer pool, then\n<a class=\"reference internal\" href=\"#term-secondary-storage\"><span class=\"xref std std-term\">secondary storage</span></a> need not be accessed.\nIf the value is not found in the buffer pool, then it must be\nfetched from secondary storage.\nA number of traditional <a class=\"reference internal\" href=\"#term-heuristic\"><span class=\"xref std std-term\">heuristics</span></a>\nhave been developed for deciding which data to <a class=\"reference internal\" href=\"#term-2\"><span class=\"xref std std-term\">flush</span></a>\nfrom the buffer pool when new data must be stored,\nsuch as <a class=\"reference internal\" href=\"#term-least-recently-used\"><span class=\"xref std std-term\">least recently used</span></a>.</p>\n</dd>", "flush": "removing the contents stored in a <a class=\"reference internal\" href=\"#term-buffer\"><span class=\"xref std std-term\">buffer</span></a>\nwhen that buffer is required in order to store new data.\nIf the buffer\u2019s contents have been changed since having been\nread in from <a class=\"reference internal\" href=\"#term-backing-storage\"><span class=\"xref std std-term\">backing storage</span></a> (this fact would\nnormally be tracked by using a <a class=\"reference internal\" href=\"#term-dirty-bit\"><span class=\"xref std std-term\">dirty bit</span></a>),\nthen they must be copied back to the backing storage before the\nbuffer can be reused.</p>\n</dd>", "caching": "The goal is to have in main memory the data values that are\nmost likely to be used in the near future.\nAn example of a caching technique is the use of a\n<a class=\"reference internal\" href=\"#term-buffer-pool\"><span class=\"xref std std-term\">buffer pool</span></a>.</p>\n</dd>", "buffering": "More specifically, it refers to an arrangement where all\naccesses to data (such as on a\n<a class=\"reference internal\" href=\"#term-peripheral-storage\"><span class=\"xref std std-term\">peripheral storage</span></a> device) must\nbe done in multiples of some minimum unit of storage.\nOn a <a class=\"reference internal\" href=\"#term-disk-drive\"><span class=\"xref std std-term\">disk drive</span></a>, this basic or smallest unit of I/O is a\n<a class=\"reference internal\" href=\"#term-sector\"><span class=\"xref std std-term\">sector</span></a>.\nIt is called \u201cbuffering\u201d because the block of data returned by\nsuch an access is stored in a <a class=\"reference internal\" href=\"#term-buffer\"><span class=\"xref std std-term\">buffer</span></a>.</p>\n</dd>", "class": "an ADT and its implementation together make up a class.\nAn instantiation of a class within a program is termed an\n<a class=\"reference internal\" href=\"#term-object\"><span class=\"xref std std-term\">object</span></a>.</p>\n</dd>", "member function": "member function or <a class=\"reference internal\" href=\"#term-method\"><span class=\"xref std std-term\">method</span></a>.</p>\n</dd>", "data member": "item are referred to as data members.\nSome of the commonly used synonyms include <a class=\"reference internal\" href=\"#term-data-field\"><span class=\"xref std std-term\">data field</span></a>,\n<a class=\"reference internal\" href=\"#term-attribute\"><span class=\"xref std std-term\">attribute</span></a>, and <a class=\"reference internal\" href=\"#term-instance-variable\"><span class=\"xref std std-term\">instance variable</span></a>.</p>\n</dd>", "closed hash system": "the <a class=\"reference internal\" href=\"#term-hash-table\"><span class=\"xref std std-term\">hash table</span></a>.\nThis is in contrast to an <a class=\"reference internal\" href=\"#term-open-hash-system\"><span class=\"xref std std-term\">open hash system</span></a>.</p>\n</dd>", "open addressing": "</dd>", "code optimization": "(typically <a class=\"reference internal\" href=\"#term-assembly-code\"><span class=\"xref std std-term\">assembly code</span></a>) with the goal of replacing\nit with a version of the code that will run faster while\nperforming the same computation.</p>\n</dd>", "collision resolution policy": "<a class=\"reference internal\" href=\"#term-collision\"><span class=\"xref std std-term\">collision</span></a>.\nSpecifically in a <a class=\"reference internal\" href=\"#term-closed-hash-system\"><span class=\"xref std std-term\">closed hash system</span></a>, this is the\nprocess of finding the proper position in a <a class=\"reference internal\" href=\"#term-hash-table\"><span class=\"xref std std-term\">hash table</span></a>\nthat contains the\ndesired record if the <a class=\"reference internal\" href=\"#term-hash-function\"><span class=\"xref std std-term\">hash function</span></a> did not return the\ncorrect position for that record due to a <a class=\"reference internal\" href=\"#term-collision\"><span class=\"xref std std-term\">collision</span></a> with\nanother record.</p>\n</dd>", "collision resolution": "</dd>", "compiler": "them into a form that can be directly excecuted by some form of\ncomputer.\nThe major phases in a compiler include <a class=\"reference internal\" href=\"#term-lexical-analysis\"><span class=\"xref std std-term\">lexical analysis</span></a>,\n<a class=\"reference internal\" href=\"#term-syntax-analysis\"><span class=\"xref std std-term\">syntax analysis</span></a>, <a class=\"reference internal\" href=\"#term-intermediate-code-generation\"><span class=\"xref std std-term\">intermediate code generation</span></a>,\n<a class=\"reference internal\" href=\"#term-code-optimization\"><span class=\"xref std std-term\">code optimization</span></a>, and <a class=\"reference internal\" href=\"#term-code-generation\"><span class=\"xref std std-term\">code generation</span></a>.\nMore broadly, a compiler can be viewed as <a class=\"reference internal\" href=\"#term-parser\"><span class=\"xref std std-term\">parsing</span></a> the program to verify that it is syntactically\ncorrect, and then doing <a class=\"reference internal\" href=\"#term-code-generation\"><span class=\"xref std std-term\">code generation</span></a> to convert the\nhig-level program into something that the computer can execute.</p>\n</dd>", "lexical analysis": "for reading in characters of the program or language and grouping\nthem into <a class=\"reference internal\" href=\"#term-token\"><span class=\"xref std std-term\">tokens</span></a>.</p>\n</dd>", "syntax analysis": "<a class=\"reference internal\" href=\"#term-token\"><span class=\"xref std std-term\">tokens</span></a>, checks if program is syntactically\ncorrect, and then generates a <a class=\"reference internal\" href=\"#term-parse-tree\"><span class=\"xref std std-term\">parse tree</span></a>.</p>\n</dd>", "intermediate code generation": "<a class=\"reference internal\" href=\"#term-parse-tree\"><span class=\"xref std std-term\">parse tree</span></a> to produce simple <a class=\"reference internal\" href=\"#term-assembly-code\"><span class=\"xref std std-term\">assembly code</span></a>.</p>\n</dd>", "code generation": "<a class=\"reference internal\" href=\"#term-intermediate-code\"><span class=\"xref std std-term\">intermediate code</span></a> into the final executable form of the\ncode.\nMore generally, this can refer to the process of turning a parse\ntree (that determines the correctness of the structure of the\nprogram) into actual instructions that the computer can execute.</p>\n</dd>", "compile-time polymorphism": "Overloaded methods have the same names, but different signatures\nas a method available elsewhere in the class.\nCompare to <a class=\"reference internal\" href=\"#term-run-time-polymorphism\"><span class=\"xref std std-term\">run-time polymorphism</span></a>.</p>\n</dd>", "Overloading": "", "cycle": "a <a class=\"reference internal\" href=\"#term-cycle\"><span class=\"xref std std-term\">cycle</span></a> is a <a class=\"reference internal\" href=\"#term-path\"><span class=\"xref std std-term\">path</span></a> of length three or more that\nconnects some <a class=\"reference internal\" href=\"#term-vertex\"><span class=\"xref std std-term\">vertex</span></a> <span class=\"math notranslate nohighlight\">\\(v_1\\)</span> to itself.</p>\n</dd>", "path": "a sequence of <a class=\"reference internal\" href=\"#term-vertex\"><span class=\"xref std std-term\">vertices</span></a>\n<span class=\"math notranslate nohighlight\">\\(v_1, v_2, ..., v_n\\)</span>\nforms a path of length <span class=\"math notranslate nohighlight\">\\(n-1\\)</span> if there exist edges from\n<span class=\"math notranslate nohighlight\">\\(v_i\\)</span> to <span class=\"math notranslate nohighlight\">\\(v_{i+1}\\)</span> for <span class=\"math notranslate nohighlight\">\\(1 \\leq i &lt; n\\)</span>.</p>\n</dd>", "simple cycle": "corresponding <a class=\"reference internal\" href=\"#term-path\"><span class=\"xref std std-term\">path</span></a> is simple, except that the first and\nlast <a class=\"reference internal\" href=\"#term-vertex\"><span class=\"xref std std-term\">vertices</span></a> of the cycle are the same.</p>\n</dd>", "data item": "</dd>", "data field": "a synonym for <a class=\"reference internal\" href=\"#term-data-member\"><span class=\"xref std std-term\">data member</span></a>.</p>\n</dd>", "attribute": "a synonym for <a class=\"reference internal\" href=\"#term-data-member\"><span class=\"xref std std-term\">data members</span></a>.</p>\n</dd>", "instance variable": "a synonym for <a class=\"reference internal\" href=\"#term-data-member\"><span class=\"xref std std-term\">data member</span></a>.</p>\n</dd>", "data structure": "</dd>", "serialization": "representing it as a sequence of bytes.\nThis is sometimes done in order to transmit the data structure\nacross a network or store the data structure in a\n<a class=\"reference internal\" href=\"#term-stream\"><span class=\"xref std std-term\">stream</span></a>, such as on disk.\n<a class=\"reference internal\" href=\"#term-deserialization\"><span class=\"xref std std-term\">Deserialization</span></a> reconstructs the\noriginal data structure from the serialized representation.</p>\n</dd>", "data type": "the type.</p>\n</dd>", "simple type": "An example is the integers.</p>\n</dd>", "list": "<a class=\"reference internal\" href=\"#term-element\"><span class=\"xref std std-term\">elements</span></a>.\nThis is close to the mathematical concept of a <a class=\"reference internal\" href=\"#term-sequence\"><span class=\"xref std std-term\">sequence</span></a>.\nNote that \u201cordered\u201d in this definition means that the list\nelements have position.\nIt does not refer to the relationship\nbetween <a class=\"reference internal\" href=\"#term-key\"><span class=\"xref std std-term\">key</span></a> values for the list elements (that is,\n\u201cordered\u201d does not mean \u201csorted\u201d).</p>\n</dd>", "depth-first search": "Whenever a <span class=\"math notranslate nohighlight\">\\(v\\)</span> is <a class=\"reference internal\" href=\"#term-visit\"><span class=\"xref std std-term\">visited</span></a> during the\ntraversal, DFS will <a class=\"reference internal\" href=\"#term-recursion\"><span class=\"xref std std-term\">recursively</span></a> visit all of\n<span class=\"math notranslate nohighlight\">\\(v\\)</span> \u2018s <a class=\"reference internal\" href=\"#term-unvisited\"><span class=\"xref std std-term\">unvisited</span></a> <a class=\"reference internal\" href=\"#term-neighbor\"><span class=\"xref std std-term\">neighbors</span></a>.</p>\n</dd>", "DFS": "</dd>", "depth-first search tree": "<a class=\"reference internal\" href=\"#term-depth-first-search\"><span class=\"xref std std-term\">depth-first search</span></a> (DFS) on a <a class=\"reference internal\" href=\"#term-graph\"><span class=\"xref std std-term\">graph</span></a>.\nThis tree would consist of the <a class=\"reference internal\" href=\"#term-node\"><span class=\"xref std std-term\">nodes</span></a> of the graph\nand a subset of the <a class=\"reference internal\" href=\"#term-edge\"><span class=\"xref std std-term\">edges</span></a> of the graph that was\nfollowed during the DFS.</p>\n</dd>", "design pattern": "that is, the interactions of objects and classes.\nExperienced software designers learn and reuse patterns\nfor combining software components, and design patterns allow\nthis design knowledge to be passed on to new programmers more quickly.</p>\n</dd>", "Composite design pattern": "container for a collection of objects, the composite\n<a class=\"reference internal\" href=\"#term-design-pattern\"><span class=\"xref std std-term\">design pattern</span></a> addresses the relationship between the\nobject hierarchy and a bunch of behaviors on the objects.\nIn the composite design, each object is required to implement\nthe collection of behaviors.\nThis is in contrast to the procedural approach where a behavior\n(such as a tree <a class=\"reference internal\" href=\"#term-traversal\"><span class=\"xref std std-term\">traversal</span></a>) is implemented as a\nmethod on  the object collection (such as a <a class=\"reference internal\" href=\"#term-tree\"><span class=\"xref std std-term\">tree</span></a>).\nProcedural tree traversal requires that the tree have a method\nthat understands what to do when it encounters any of the object\ntypes (<a class=\"reference internal\" href=\"#term-internal-node\"><span class=\"xref std std-term\">internal</span></a> or\n<a class=\"reference internal\" href=\"#term-leaf-node\"><span class=\"xref std std-term\">leaf nodes</span></a>) that the tree might contain.\nThe composite approach would have the tree call the \u201ctraversal\u201d\nmethod on its root node, which then knows how to perform the\n\u201ctraversal\u201d behavior.\nThis might in turn require invoking the traversal method of\nother objects (in this case, the children of the root).</p>\n</dd>", "strategy": "algorithm.\nAlso the name for a <a class=\"reference internal\" href=\"#term-design-pattern\"><span class=\"xref std std-term\">design pattern</span></a> that separates the\nalgorithm for performing a task from the control for applying\nthat task to each member of a collection.\nA good example is a generic sorting function that takes a\ncollection of records (such as an <a class=\"reference internal\" href=\"#term-array\"><span class=\"xref std std-term\">array</span></a>) and a \u201cstrategy\u201d in the\nform of an algorithm that knows how to extract the key from a\nrecord in the array.\nOnly subtly different from the <a class=\"reference internal\" href=\"#term-visitor\"><span class=\"xref std std-term\">visitor</span></a> design pattern,\nwhere the difference is primarily one of intent rather than\nsyntax.\nThe strategy design pattern is focused on encapsulating an\nactivity that is part of a larger process, so that different\nways of performing that activity can be substituted.\nThe visitor design pattern is focused on encapsulating an\nactivity that will be performed on all members of a collection\nso that completely different activities can be substituted\nwithin a generic method that accesses all of the collection\nmembers.</p>\n</dd>", "visitor": "given a function (known as the visitor) that is applied to every\nobject in the collection being traversed.\nFor example, a generic tree or graph traversal might be\ndesigned such that it takes a function parameter,\nwhere that function is applied to each node.</p>\n</dd>", "DAG": "</dd>", "directed graph": "from one of its defining <a class=\"reference internal\" href=\"#term-vertex\"><span class=\"xref std std-term\">vertices</span></a> to the\nother.</p>\n</dd>", "digraph": "</dd>", "disk drive": "<a class=\"reference internal\" href=\"#term-secondary-storage\"><span class=\"xref std std-term\">secondary storage</span></a>.\nData access times are typically measured in thousandths of a\nsecond (milliseconds), which\nis roughly a million times slower than access times for\n<a class=\"reference internal\" href=\"#term-ram\"><span class=\"xref std std-term\">RAM</span></a>, which is an example of a <a class=\"reference internal\" href=\"#term-primary-storage\"><span class=\"xref std std-term\">primary storage</span></a>\ndevice.\nReads from and writes to a disk drive are always done in terms\nof some minimum size, which is typically called a\n<a class=\"reference internal\" href=\"#term-block\"><span class=\"xref std std-term\">block</span></a>.\nThe block size is 512 bytes on most disk drives.\nDisk drives and RAM are typical parts of a computer\u2019s\n<a class=\"reference internal\" href=\"#term-memory-hierarchy\"><span class=\"xref std std-term\">memory hierarchy</span></a>.</p>\n</dd>", "peripheral storage": "of the computer (that is, <a class=\"reference internal\" href=\"#term-ram\"><span class=\"xref std std-term\">RAM</span></a>).\nA typical example is a <a class=\"reference internal\" href=\"#term-disk-drive\"><span class=\"xref std std-term\">disk drive</span></a>.</p>\n</dd>", "disk I/O": "<a class=\"reference internal\" href=\"#term-disk-drive\"><span class=\"xref std std-term\">disk drive</span></a>.\nAll disk reads and writes are done in units of a <a class=\"reference internal\" href=\"#term-sector\"><span class=\"xref std std-term\">sector</span></a>\nor <a class=\"reference internal\" href=\"#term-block\"><span class=\"xref std std-term\">block</span></a>.</p>\n</dd>", "block": "<a class=\"reference internal\" href=\"#term-disk-drive\"><span class=\"xref std std-term\">disk drive</span></a> or other <a class=\"reference internal\" href=\"#term-peripheral-storage\"><span class=\"xref std std-term\">peripheral storage</span></a> device.\nA block is the basic unit of I/O for that device.</p>\n</dd>", "sector": "data that will be read or written at one time by the disk drive\nhardware.\nThis is typically 512 bytes.</p>\n</dd>", "dynamic allocation": "In C++, Java, and JavaScript, this is done using the <code class=\"docutils literal notranslate\"><span class=\"pre\">new</span></code>\noperator.</p>\n</dd>", "node": "list or binary tree.\nTypically, nodes are allocated using\n<a class=\"reference internal\" href=\"#term-dynamic-memory-allocation\"><span class=\"xref std std-term\">dynamic memory allocation</span></a>.\nIn <a class=\"reference internal\" href=\"#term-graph\"><span class=\"xref std std-term\">graph</span></a> terminology, the nodes are more commonly called\n<a class=\"reference internal\" href=\"#term-vertex\"><span class=\"xref std std-term\">vertices</span></a>.</p>\n</dd>", "dynamic programming": "of results for subproblems.\nA typical cause for excessive cost in\n<a class=\"reference internal\" href=\"#term-recursion\"><span class=\"xref std std-term\">recursive</span></a>\nalgorithms is that different branches of the recursion might\nsolve the same subproblem.\nDynamic programming uses a table to store information about\nwhich subproblems have already been solved, and uses the stored\ninformation to immediately give the answer for any repeated\nattempts to solve that subproblem.</p>\n</dd>", "Finite Automata": "", "state machine": "", "states": "", "accepting states <accepting states>": "", "Deterministic Finite Automata": "input string (shown on a tape) from left to right.\nThere is a control unit (with <a class=\"reference internal\" href=\"#term-state\"><span class=\"xref std std-term\">states</span></a>),\nbehavior defined for what to do when in a given state and with a\ngiven symbol on the current square of the tape.\nAll that we can \u201cdo\u201d is change state before going to the next\nletter to the right.</p>\n</dd>", "k-path": "vertices <span class=\"math notranslate nohighlight\">\\(i\\)</span> and <span class=\"math notranslate nohighlight\">\\(j\\)</span> that can only go through\nvertices with an index value less than or equal to <span class=\"math notranslate nohighlight\">\\(k\\)</span>.</p>\n</dd>", "graph": "consists of a set of <a class=\"reference internal\" href=\"#term-vertex\"><span class=\"xref std std-term\">vertices</span></a>\n<span class=\"math notranslate nohighlight\">\\(\\mathbf{V}\\)</span> and a set of <a class=\"reference internal\" href=\"#term-edge\"><span class=\"xref std std-term\">edges</span></a>\n<span class=\"math notranslate nohighlight\">\\(\\mathbf{E}\\)</span>, such that each edge in <span class=\"math notranslate nohighlight\">\\(\\mathbf{E}\\)</span> is\na connection between a pair of vertices in <span class=\"math notranslate nohighlight\">\\(\\mathbf{V}\\)</span>.</p>\n</dd>", "edges <edge>": "", "vertices <vertex>": "", "adjacency matrix": "<a class=\"reference internal\" href=\"#term-array\"><span class=\"xref std std-term\">array</span></a> where each row and each column corresponds to a\n<a class=\"reference internal\" href=\"#term-vertex\"><span class=\"xref std std-term\">vertex</span></a> in the <a class=\"reference internal\" href=\"#term-graph\"><span class=\"xref std std-term\">graph</span></a>. A given row and column in\nthe matrix corresponds to an edge from the <a class=\"reference internal\" href=\"#term-vertex\"><span class=\"xref std std-term\">vertex</span></a>\ncorresponding to the row to the vertex corresponding to the\ncolumn.</p>\n</dd>", "adjacency list": "<a class=\"reference internal\" href=\"#term-list\"><span class=\"xref std std-term\">list</span></a> to represent the <a class=\"reference internal\" href=\"#term-vertex\"><span class=\"xref std std-term\">vertices</span></a> of the\ngraph, and each vertex is in turn represented by a\n(linked) list of the vertices that are\n<a class=\"reference internal\" href=\"#term-neighbor\"><span class=\"xref std std-term\">neighbors</span></a>.</p>\n</dd>", "traversal": "(such as a <a class=\"reference internal\" href=\"#term-tree\"><span class=\"xref std std-term\">tree</span></a> or <a class=\"reference internal\" href=\"#term-graph\"><span class=\"xref std std-term\">graph</span></a>) in some order.</p>\n</dd>", "topological sort": "<a class=\"reference internal\" href=\"#term-dag\"><span class=\"xref std std-term\">DAG</span></a> in a <a class=\"reference internal\" href=\"#term-linear-order\"><span class=\"xref std std-term\">linear order</span></a> such that no vertex\n<span class=\"math notranslate nohighlight\">\\(A\\)</span> in the order is preceded by a vertex that can be\nreached by a (directed) <a class=\"reference internal\" href=\"#term-path\"><span class=\"xref std std-term\">path</span></a> from <span class=\"math notranslate nohighlight\">\\(A\\)</span>.\nUsually the (directed) edges in the graph define a\nprerequisite system, and the goal of the topological sort is\nto list the vertices in an order such that no prerequisites are\nviolated.</p>\n</dd>", "shortest paths": "", "dense graph": "is a large fraction of the possible number of edges.\nGenerally, this is interpreted to mean that the <a class=\"reference internal\" href=\"#term-degree\"><span class=\"xref std std-term\">degree</span></a>\nfor any <a class=\"reference internal\" href=\"#term-vertex\"><span class=\"xref std std-term\">vertex</span></a> in the graph is relatively high.</p>\n</dd>", "sparse graph": "is much less than the possible number of edges.\nGenerally, this is interpreted to mean that the <a class=\"reference internal\" href=\"#term-degree\"><span class=\"xref std std-term\">degree</span></a>\nfor any <a class=\"reference internal\" href=\"#term-vertex\"><span class=\"xref std std-term\">vertex</span></a> in the graph is relatively low.</p>\n</dd>", "labeled graph": "<a class=\"reference internal\" href=\"#term-node\"><span class=\"xref std std-term\">nodes</span></a>.</p>\n</dd>", "undirected graph": "</dd>", "weighted graph": "associated <a class=\"reference internal\" href=\"#term-weight\"><span class=\"xref std std-term\">weight</span></a> or cost.</p>\n</dd>", "unweighted graph": "", "hash system": "<a class=\"reference internal\" href=\"#term-hash-table\"><span class=\"xref std std-term\">hash table</span></a>.\nThe <a class=\"reference internal\" href=\"#term-search-key\"><span class=\"xref std std-term\">search key</span></a> is processed by a\n<a class=\"reference internal\" href=\"#term-hash-function\"><span class=\"xref std std-term\">hash function</span></a>, which returns a position in a\n<a class=\"reference internal\" href=\"#term-hash-table\"><span class=\"xref std std-term\">hash table</span></a>, which hopefully is the correct position in\nwhich to find the record corresponding to the search key.</p>\n</dd>", "hash function": "<a class=\"reference internal\" href=\"#term-key\"><span class=\"xref std std-term\">key</span></a> value to a position in the <a class=\"reference internal\" href=\"#term-hash-table\"><span class=\"xref std std-term\">hash table</span></a>.\nThe hope is that this position in the hash table contains the\nrecord that matches the key value.</p>\n</dd>", "open hash system": "with the same slot of a <a class=\"reference internal\" href=\"#term-hash-table\"><span class=\"xref std std-term\">hash table</span></a>.\nTypically this is done using a linked list to store the records.\nThis is in contrast to a <a class=\"reference internal\" href=\"#term-closed-hash-system\"><span class=\"xref std std-term\">closed hash system</span></a>.</p>\n</dd>", "hashing": "<a class=\"reference internal\" href=\"#term-search-key\"><span class=\"xref std std-term\">search key</span></a> value into a position within a\n<a class=\"reference internal\" href=\"#term-hash-table\"><span class=\"xref std std-term\">hash table</span></a>.\nIn a properly implemented <a class=\"reference internal\" href=\"#term-hash-system\"><span class=\"xref std std-term\">hash system</span></a>, that position in\nthe table will have high probability of containing the record\nthat matches the key value.\nSometimes, the hash function will return an position that does\nnot store the desired key, due to a process called\n<a class=\"reference internal\" href=\"#term-collision\"><span class=\"xref std std-term\">collision</span></a>.\nIn that case, the desired record is found through a process\nknown as <a class=\"reference internal\" href=\"#term-collision-resolution\"><span class=\"xref std std-term\">collision resolution</span></a>.</p>\n</dd>", "hash table": "records for lookup using <a class=\"reference internal\" href=\"#term-hashing\"><span class=\"xref std std-term\">hashing</span></a>.</p>\n</dd>", "heap": "Uncommonly, it is a synonym for <a class=\"reference internal\" href=\"#term-free-store\"><span class=\"xref std std-term\">free store</span></a>.\nMost often it is used to refer to a particular data structure.\nThis data structure is a <a class=\"reference internal\" href=\"#term-complete-binary-tree\"><span class=\"xref std std-term\">complete binary tree</span></a> with the\nrequirement that every <a class=\"reference internal\" href=\"#term-node\"><span class=\"xref std std-term\">node</span></a> has a value greater than its\n<a class=\"reference internal\" href=\"#term-child\"><span class=\"xref std std-term\">children</span></a> (called a <a class=\"reference internal\" href=\"#term-max-heap\"><span class=\"xref std std-term\">max heap</span></a>), or else\nthe requirement that every node has a value less than its\nchildren (called a <a class=\"reference internal\" href=\"#term-min-heap\"><span class=\"xref std std-term\">min heap</span></a>).\nSince it is a complete binary tree, a heap is nearly always\nimplemented using an <a class=\"reference internal\" href=\"#term-array\"><span class=\"xref std std-term\">array</span></a> rather than an explicit tree\nstructure.\nTo add a new value to a heap, or to remove the extreme value\n(the max value in a max-heap or min value in a min-heap) and\nupdate the heap,\ntakes <span class=\"math notranslate nohighlight\">\\(\\Theta(\\log n)\\)</span> time in the <a class=\"reference internal\" href=\"#term-worst-case\"><span class=\"xref std std-term\">worst case</span></a>.\nHowever, if given all of the values in an unordered array,\nthe values can be re-arranged to form a heap in only\n<span class=\"math notranslate nohighlight\">\\(\\Theta(n)\\)</span> time.\nDue to its space and time efficiency, the heap is a\npopular choice for implementing a <a class=\"reference internal\" href=\"#term-priority-queue\"><span class=\"xref std std-term\">priority queue</span></a>.</p>\n</dd>", "priority queue": "deletion of the greatest (or, in an alternative implementation,\nthe least) valued record.\nMost often implemented using the <a class=\"reference internal\" href=\"#term-heap\"><span class=\"xref std std-term\">heap</span></a> data structure.\nThe name comes from a common application where the records being\nstored represent tasks, with the ordering values based on the\n<a class=\"reference internal\" href=\"#term-priority\"><span class=\"xref std std-term\">priorities</span></a> of the tasks.</p>\n</dd>", "max heap": "greater than its <a class=\"reference internal\" href=\"#term-child\"><span class=\"xref std std-term\">children</span></a>.\nAs a consequence, the node with maximum key value is\nat the <a class=\"reference internal\" href=\"#term-root\"><span class=\"xref std std-term\">root</span></a>.</p>\n</dd>", "min heap": "less than its <a class=\"reference internal\" href=\"#term-child\"><span class=\"xref std std-term\">children</span></a>.\nAs a consequence, the node with minimum key value is\nat the <a class=\"reference internal\" href=\"#term-root\"><span class=\"xref std std-term\">root</span></a>.</p>\n</dd>", "heapsort": "the <a class=\"reference internal\" href=\"#term-best-case\"><span class=\"xref std std-term\">best</span></a>, <a class=\"reference internal\" href=\"#term-average-case\"><span class=\"xref std std-term\">average</span></a>,\nand <a class=\"reference internal\" href=\"#term-worst-case\"><span class=\"xref std std-term\">worst</span></a> cases.\nIt tends to be slower than <a class=\"reference internal\" href=\"#term-mergesort\"><span class=\"xref std std-term\">Mergesort</span></a> and\n<a class=\"reference internal\" href=\"#term-quicksort\"><span class=\"xref std std-term\">Quicksort</span></a>.\nIt works by building a <a class=\"reference internal\" href=\"#term-max-heap\"><span class=\"xref std std-term\">max heap</span></a>, and\nthen repeatedly removing the item with maximum <a class=\"reference internal\" href=\"#term-key\"><span class=\"xref std std-term\">key</span></a> value\n(moving it to the end of the heap) until all elements have been\nremoved (and replaced at their proper location in the array).</p>\n</dd>", "replacement selection": "<a class=\"reference internal\" href=\"#term-external-sort\"><span class=\"xref std std-term\">external sort</span></a>.\nGiven a collection of records stored in an <a class=\"reference internal\" href=\"#term-array\"><span class=\"xref std std-term\">array</span></a>, and a stream\nof additional records too large to fit into\n<a class=\"reference internal\" href=\"#term-working-memory\"><span class=\"xref std std-term\">working memory</span></a>, replacement selection will unload the\n<a class=\"reference internal\" href=\"#term-heap\"><span class=\"xref std std-term\">heap</span></a> by sending records to an output stream, and seek to\nbring new records into the heap from the input stream in\npreference to shrinking the heap size whenever possible.</p>\n</dd>", "inherit": "the process by which a <a class=\"reference internal\" href=\"#term-subclass\"><span class=\"xref std std-term\">subclass</span></a> gains\n<a class=\"reference internal\" href=\"#term-data-member\"><span class=\"xref std std-term\">data members</span></a> and <a class=\"reference internal\" href=\"#term-method\"><span class=\"xref std std-term\">methods</span></a>\nfrom a <a class=\"reference internal\" href=\"#term-base-class\"><span class=\"xref std std-term\">base class</span></a>.</p>\n</dd>", "base class": "a class from which another class <a class=\"reference internal\" href=\"#term-inherit\"><span class=\"xref std std-term\">inherits</span></a>.\nThe class that inherits is called a <a class=\"reference internal\" href=\"#term-subclass\"><span class=\"xref std std-term\">subclass</span></a>.</p>\n</dd>", "subclass": "any class within a <a class=\"reference internal\" href=\"#term-class-hierarchy\"><span class=\"xref std std-term\">class hierarchy</span></a> that\n<a class=\"reference internal\" href=\"#term-inherit\"><span class=\"xref std std-term\">inherits</span></a> from some other class.</p>\n</dd>", "Parse tree": "", "kd tree": "store a collection of data records based on their (point)\nlocation in space.\nIt uses the concept of a <a class=\"reference internal\" href=\"#term-discriminator\"><span class=\"xref std std-term\">discriminator</span></a> at each level to\ndecide which single component of the\n<a class=\"reference internal\" href=\"#term-multi-dimensional-search-key\"><span class=\"xref std std-term\">multi-dimensional search key</span></a> to branch on at that level.\nIt uses a <a class=\"reference internal\" href=\"#term-key-space-decomposition\"><span class=\"xref std std-term\">key-space decomposition</span></a>, meaning that all data\nrecords in the left subtree of a node have a value on the\ncorresponding discriminator that is less than that of the node,\nwhile all data records in the right subtree have a greater\nvalue.\nThe <a class=\"reference internal\" href=\"#term-bintree\"><span class=\"xref std std-term\">bintree</span></a> is the <a class=\"reference internal\" href=\"#term-image-space-decomposition\"><span class=\"xref std std-term\">image-space decomposition</span></a>\nanalog of the kd tree.</p>\n</dd>", "discriminator": "Certain tree data structures such as the <a class=\"reference internal\" href=\"#term-bintree\"><span class=\"xref std std-term\">bintree</span></a> and the\n<a class=\"reference internal\" href=\"#term-kd-tree\"><span class=\"xref std std-term\">kd tree</span></a> operate by making branching decisions at nodes\nof the tree based on a single attribute of the multi-dimensional\nkey, with the attribute determined by the level of the node in\nthe tree.\nFor example, in 2 dimensions, nodes at the odd levels in the\ntree might branch based on the <span class=\"math notranslate nohighlight\">\\(x\\)</span> value of a coordinate,\nwhile at the even levels the tree would branch based on the\n<span class=\"math notranslate nohighlight\">\\(y\\)</span> value of the coordinate.\nThus, the <span class=\"math notranslate nohighlight\">\\(x\\)</span> coordinate is the discriminator for the odd\nlevels, while the <span class=\"math notranslate nohighlight\">\\(y\\)</span> coordinate is the discriminator for\nthe even levels.</p>\n</dd>", "key": "for the purpose of searching or comparing.\nAnother term for <a class=\"reference internal\" href=\"#term-search-key\"><span class=\"xref std std-term\">search key</span></a>.</p>\n</dd>", "key space": "</dd>", "key sort": "<a class=\"reference internal\" href=\"#term-key-value-pair\"><span class=\"xref std std-term\">key-value pairs</span></a> where the value in this\ncase is a <a class=\"reference internal\" href=\"#term-reference\"><span class=\"xref std std-term\">reference</span></a> to a complete record (that is, a\npointer to the record in memory or a position for a record on\ndisk).\nThis is in contrast to a sorting operation that works directly\non a collection of records.\nThe intention is that the collection of key-value pairs is far\nsmaller than the collection of records themselves.\nAs such, this might allow for an <a class=\"reference internal\" href=\"#term-internal-sort\"><span class=\"xref std std-term\">internal sort</span></a> when\nsorting the records directly would require an <a class=\"reference internal\" href=\"#term-external-sort\"><span class=\"xref std std-term\">external\nsort</span></a>.\nThe collection of key-value pairs can also act as an\n<a class=\"reference internal\" href=\"#term-indexing\"><span class=\"xref std std-term\">index</span></a>.</p>\n</dd>", "key-space decomposition": "into pieces.\nThere are two general approaches to this:\n<a class=\"reference internal\" href=\"#term-object-space-decomposition\"><span class=\"xref std std-term\">object-space decomposition</span></a> and\n<a class=\"reference internal\" href=\"#term-image-space-decomposition\"><span class=\"xref std std-term\">image-space decomposition</span></a>.</p>\n</dd>", "object-space decomposition": "<a class=\"reference internal\" href=\"#term-key-space\"><span class=\"xref std std-term\">key space</span></a> is determined\nby the actual values of keys that are found.\nFor example, a <a class=\"reference internal\" href=\"#term-bst\"><span class=\"xref std std-term\">BST</span></a> stores a key value in its root,\nand all other values in the tree with lesser value are in the\nleft <a class=\"reference internal\" href=\"#term-subtree\"><span class=\"xref std std-term\">subtree</span></a>.\nThus, the root value has split (or decomposed) the\nkey space for that key based on its value into left\nand right parts.\nAn object-space decomposition is in opposition to an\n<a class=\"reference internal\" href=\"#term-image-space-decomposition\"><span class=\"xref std std-term\">image-space decomposition</span></a>.</p>\n</dd>", "image-space decomposition": "<a class=\"reference internal\" href=\"#term-key-space\"><span class=\"xref std std-term\">key space</span></a> splitting points is predetermined (typically\nby splitting in half).\nFor example, a <a class=\"reference internal\" href=\"#term-huffman-coding-tree\"><span class=\"xref std std-term\">Huffman coding tree</span></a> splits the letters\nbeing coded into those with codes that start with 0 on the left\nside, and those with codes that start with 1 on the right side.\nThis regular decomposition of the key space is the basis for a\n<a class=\"reference internal\" href=\"#term-trie\"><span class=\"xref std std-term\">trie</span></a> data structure.\nAn image-space decomposition is in opposition to an\n<a class=\"reference internal\" href=\"#term-object-space-decomposition\"><span class=\"xref std std-term\">object-space decomposition</span></a>.</p>\n</dd>", "Kruskal's algorithm": "", "UNION/FIND": "The <a class=\"reference internal\" href=\"#term-find\"><span class=\"xref std std-term\">FIND</span></a> operation determines which disjoint set a given\nobject resides in, and the <a class=\"reference internal\" href=\"#term-union\"><span class=\"xref std std-term\">UNION</span></a> operation combines two\ndisjoint sets when it is determined that they are members of the\nsame <a class=\"reference internal\" href=\"#term-equivalence-class\"><span class=\"xref std std-term\">equivalence class</span></a> under some\n<a class=\"reference internal\" href=\"#term-equivalence-relation\"><span class=\"xref std std-term\">equivalence relation</span></a>.</p>\n</dd>", "interpreter": "program into something that can be repeatedly executed to\nperform a computation, an interpreter directly performs\ncomputation on the high-level langauge.\nThis tends to make the computation much slower than if it were\nperformed on the directly executable version produced by a\ncompiler.</p>\n</dd>", "linked list": "<a class=\"reference internal\" href=\"#term-dynamic-allocation\"><span class=\"xref std std-term\">dynamic allocation</span></a>\nof <a class=\"reference internal\" href=\"#term-link-node\"><span class=\"xref std std-term\">link nodes</span></a> to store the list elements.\nCommon variants are the <a class=\"reference internal\" href=\"#term-singly-linked-list\"><span class=\"xref std std-term\">singly linked list</span></a>,\n<a class=\"reference internal\" href=\"#term-doubly-linked-list\"><span class=\"xref std std-term\">doubly linked list</span></a> and <a class=\"reference internal\" href=\"#term-circular-list\"><span class=\"xref std std-term\">circular list</span></a>.\nThe <a class=\"reference internal\" href=\"#term-overhead\"><span class=\"xref std std-term\">overhead</span></a> required is the pointers in each link node.</p>\n</dd>", "automatic variable": "When program flow enters and leaves the variable\u2019s scope,\nautomatic variables will be allocated and de-allocated\nautomatically.</p>\n</dd>", "stack variable": "</dd>", "locality of reference": "evenly distributed.\nThis can express itself as some small fraction of the records\nreceiving the bulk of the accesses (<a class=\"reference internal\" href=\"#term-80-20-rule\"><span class=\"xref std std-term\">80/20 rule</span></a>).\nAlternatively, it can express itself as an increased probability\nthat the next or future accesses will come close to the most\nrecent access.\nThis is the fundamental property for success of <a class=\"reference internal\" href=\"#term-caching\"><span class=\"xref std std-term\">caching</span></a>.</p>\n</dd>", "80/20 rule": "records and a series of search operations for records,\nthe 80/20 rule is an empirical observation that\n80% of the record accessess typically go to 20% of the records.\nThe exact values varies between data collections, and is related\nto the concept of <a class=\"reference internal\" href=\"#term-locality-of-reference\"><span class=\"xref std std-term\">locality of reference</span></a>.</p>\n</dd>", "lower bounds proof": "referring to the lower bound for any possible algorithm to solve\na given <a class=\"reference internal\" href=\"#term-problem\"><span class=\"xref std std-term\">problem</span></a>.\nMany problems have a simple lower bound based on the concept\nthat the minimum amount of processing is related to looking at\nall of the problem\u2019s input.\nHowever, some problems have a higher lower bound than that.\nFor example, the lower bound for the problem of sorting\n(<span class=\"math notranslate nohighlight\">\\(\\Omega(n \\log n)\\)</span>) is greater than the input size to\nsorting (<span class=\"math notranslate nohighlight\">\\(n\\)</span>).\nProving such \u201cnon-trivial\u201d lower bounds for problems is\nnotoriously difficult.</p>\n</dd>", "adversary argument": "(fictional) \u201cadversary\u201d is assumed to control access to an\nalgorithm\u2019s input, and which yields information about that input\nin such a way\nthat will drive the cost for any proposed algorithm to solve the\nproblem as high as possible.\nSo long as the adversary never gives an answer that conflicts\nwith any previous answer, it is permitted to do whatever\nnecessary to make the algorithm require as much cost as\npossible.</p>\n</dd>", "sorting lower bound": "<a class=\"reference internal\" href=\"#term-sorting-problem\"><span class=\"xref std std-term\">sorting</span></a> is <span class=\"math notranslate nohighlight\">\\(\\Omega(n \\log n)\\)</span>.\nThis is traditionally proved using a <a class=\"reference internal\" href=\"#term-decision-tree\"><span class=\"xref std std-term\">decision tree</span></a> model\nfor sorting algorithms, and recognizing that the minimum depth\nof the decision tree for any sorting algorithm is\n<span class=\"math notranslate nohighlight\">\\(\\Omega(n \\log n)\\)</span> since there are <span class=\"math notranslate nohighlight\">\\(n!\\)</span> permutations\nof the <span class=\"math notranslate nohighlight\">\\(n\\)</span> input records to distinguish between during the\nsorting process.</p>\n</dd>", "search lower bound": "for specific variations of the problem.\nFor an unsorted array, it is <span class=\"math notranslate nohighlight\">\\(\\Omega(n)\\)</span>\n<a class=\"reference internal\" href=\"#term-comparison\"><span class=\"xref std std-term\">comparisons</span></a> in the <a class=\"reference internal\" href=\"#term-worst-case\"><span class=\"xref std std-term\">worst case</span></a>,\ntypically proved using an <a class=\"reference internal\" href=\"#term-adversary-argument\"><span class=\"xref std std-term\">adversary argument</span></a>.\nFor a sorted array, it is <span class=\"math notranslate nohighlight\">\\(\\Omega(\\log n)\\)</span> in the worst\ncase, typically proved using an argument similar to the\n<a class=\"reference internal\" href=\"#term-sorting-lower-bound\"><span class=\"xref std std-term\">sorting lower bound</span></a> proof.\nHowever, it is possible to search a sorted array in the average\ncase in <span class=\"math notranslate nohighlight\">\\(O(\\log \\log n)\\)</span> time.</p>\n</dd>", "element": "</dd>", "memory hierarchy": "storage types that range from fast but expensive\n(<a class=\"reference internal\" href=\"#term-primary-storage\"><span class=\"xref std std-term\">primary storage</span></a>) to slow but cheap\n(<a class=\"reference internal\" href=\"#term-secondary-storage\"><span class=\"xref std std-term\">secondary storage</span></a>).\nWhen there is too much data to store in <a class=\"reference internal\" href=\"#term-primary-storage\"><span class=\"xref std std-term\">primary storage</span></a>,\nthe goal is to have the data that is needed soon or\nmost often in the primary storage as much as possible,\nby using <a class=\"reference internal\" href=\"#term-caching\"><span class=\"xref std std-term\">caching</span></a> techniques.</p>\n</dd>", "primary storage": "<a class=\"reference internal\" href=\"#term-ram\"><span class=\"xref std std-term\">RAM</span></a> in modern computers.\nThis is in contrast to <a class=\"reference internal\" href=\"#term-secondary-storage\"><span class=\"xref std std-term\">secondary storage</span></a>, which together\nwith primary storage devices make up the computer\u2019s\n<a class=\"reference internal\" href=\"#term-memory-hierarchy\"><span class=\"xref std std-term\">memory hierarchy</span></a>.</p>\n</dd>", "secondary storage": "Typical examples include a <a class=\"reference internal\" href=\"#term-disk-drive\"><span class=\"xref std std-term\">disk drive</span></a>, a USB memory\nstick, or a solid state drive.</p>\n</dd>", "memory manager": "Typically, the memory pool is viewed as an <a class=\"reference internal\" href=\"#term-array\"><span class=\"xref std std-term\">array</span></a> of bytes by the\nmemory manager.\nThe <a class=\"reference internal\" href=\"#term-client\"><span class=\"xref std std-term\">client</span></a> of the memory manager will request a\ncollection of (adjacent) bytes of some size, and release the\nbytes for reuse when the space is no longer needed.\nThe memory manager should not know anything about the\ninterpretation of the data that is being stored by the client\ninto the memory pool.\nDepending on the precise implementation, the client might pass\nin the data to be stored, in which case the memory manager will\ndeal with the actual copy of the data into the memory pool.\nThe memory manager will return to the client a <a class=\"reference internal\" href=\"#term-handle\"><span class=\"xref std std-term\">handle</span></a>\nthat can later be used by the client to retrieve the data.</p>\n</dd>", "buddy method": "<a class=\"reference internal\" href=\"#term-free-block-list\"><span class=\"xref std std-term\">free block list</span></a> and a <a class=\"reference internal\" href=\"#term-sequential-fit\"><span class=\"xref std std-term\">sequential fit</span></a> method to\nseach for a suitable free block to service a\n<a class=\"reference internal\" href=\"#term-memory-request\"><span class=\"xref std std-term\">memory request</span></a>.\nInstead, the memory pool is broken down as needed into smaller\nchunks by splitting it in half repeatedly until the smallest\npower of 2 that is as big or bigger than the size of the memory\nrequest is reached.\nThe name comes from the fact that the binary representation for\nthe start of the block positions only differ by one bit for\nadjacent blocks of the same size.\nThese are referred to as \u201cbuddies\u201d and will be merged together\nif both are free.</p>\n</dd>", "minimal-cost spanning tree": "Derived from a <a class=\"reference internal\" href=\"#term-weighted-graph\"><span class=\"xref std std-term\">weighted graph</span></a>, the MCST is the\n<a class=\"reference internal\" href=\"#term-subset\"><span class=\"xref std std-term\">subset</span></a> of the graph\u2019s <a class=\"reference internal\" href=\"#term-edge\"><span class=\"xref std std-term\">edges</span></a> that\nmaintains the connectivitiy of the graph while having lowest\ntotal cost (as defined by the sum of the\n<a class=\"reference internal\" href=\"#term-weight\"><span class=\"xref std std-term\">weights</span></a> of the edges in the MCST).\nThe result is referred to as a <a class=\"reference internal\" href=\"#term-tree\"><span class=\"xref std std-term\">tree</span></a> because it would\nnever have a <a class=\"reference internal\" href=\"#term-cycle\"><span class=\"xref std std-term\">cycle</span></a> (since an edge could be removed from\nthe cycle and still preserve connectivity).\nTwo algorithms to solve this problem are\n<a class=\"reference internal\" href=\"#term-prim-s-algorithm\"><span class=\"xref std std-term\">Prim\u2019s algorithm</span></a> and <a class=\"reference internal\" href=\"#term-kruskal-s-algorithm\"><span class=\"xref std std-term\">Kruskal\u2019s algorithm</span></a>.</p>\n</dd>", "Prim's algorithm": "", "MCST": "</dd>", "MST": "", "tree": "<a class=\"reference internal\" href=\"#term-node\"><span class=\"xref std std-term\">nodes</span></a> such that there is one designated node\n<span class=\"math notranslate nohighlight\">\\(R\\)</span>, called the <a class=\"reference internal\" href=\"#term-root\"><span class=\"xref std std-term\">root</span></a> of <span class=\"math notranslate nohighlight\">\\(\\mathbf{T}\\)</span>.\nIf the set <span class=\"math notranslate nohighlight\">\\((\\mathbf{T} -\\{R\\})\\)</span> is not empty, these\nnodes are partitioned into <span class=\"math notranslate nohighlight\">\\(n &gt; 0\\)</span>\n<a class=\"reference internal\" href=\"#term-disjoint-sets\"><span class=\"xref std std-term\">disjoint sets</span></a> <span class=\"math notranslate nohighlight\">\\(\\mathbf{T}_0\\)</span>,\n<span class=\"math notranslate nohighlight\">\\(\\mathbf{T}_1\\)</span>, \u2026, <span class=\"math notranslate nohighlight\">\\(\\mathbf{T}_{n-1}\\)</span>,\neach of which is a tree, and whose <a class=\"reference internal\" href=\"#term-root\"><span class=\"xref std std-term\">roots</span></a>\n<span class=\"math notranslate nohighlight\">\\(R_1, R_2, ..., R_n\\)</span>,\nrespectively, are <a class=\"reference internal\" href=\"#term-child\"><span class=\"xref std std-term\">children</span></a> of <span class=\"math notranslate nohighlight\">\\(R\\)</span>.</p>\n</dd>", "modulus": "remainder of an integer division.\nSometimes written <span class=\"math notranslate nohighlight\">\\(n \\bmod m\\)</span> in mathematical expressions,\nthe syntax in many programming languages is <code class=\"docutils literal notranslate\"><span class=\"pre\">n</span> <span class=\"pre\">%</span> <span class=\"pre\">m</span></code>.</p>\n</dd>", "mod": "</dd>", "multi-dimensional search structure": "<a class=\"reference internal\" href=\"#term-multi-dimensional-search-key\"><span class=\"xref std std-term\">multi-dimensional search key</span></a>.\nThe main concept here is that a multi-dimensional search\nstructure works more efficiently by considering the multiple\nparts of the search key as a whole, rather than making\nindependent searches on each one-dimensional component of the\nkey.\nA primary example is a <a class=\"reference internal\" href=\"#term-spatial-data-structure\"><span class=\"xref std std-term\">spatial data structure</span></a> that can\nefficiently represent and search for records in\nmulti-dimensional space.</p>\n</dd>", "multi-dimensional search key": "conjunction with a <a class=\"reference internal\" href=\"#term-multi-dimensional-search-structure\"><span class=\"xref std std-term\">multi-dimensional search structure</span></a>.\nMost typically, a <a class=\"reference internal\" href=\"#term-spatial\"><span class=\"xref std std-term\">spatial</span></a> search key representing a\nposition in multi-dimensional (2 or 3 dimensions) space.\nBut a multi-dimensional key could be used to organize data within\nnon-spatial dimensions, such as temperature and time.</p>\n</dd>", "neighbor": "neighbor of <a class=\"reference internal\" href=\"#term-node\"><span class=\"xref std std-term\">node</span></a> <span class=\"math notranslate nohighlight\">\\(v\\)</span> if there is an <a class=\"reference internal\" href=\"#term-edge\"><span class=\"xref std std-term\">edge</span></a>\nfrom <span class=\"math notranslate nohighlight\">\\(v\\)</span> to <span class=\"math notranslate nohighlight\">\\(w\\)</span>.</p>\n</dd>", "adjacent": "<a class=\"reference internal\" href=\"#term-vertex\"><span class=\"xref std std-term\">vertices</span></a> of a <a class=\"reference internal\" href=\"#term-graph\"><span class=\"xref std std-term\">graph</span></a> are said to be\nadjacent if they have an <a class=\"reference internal\" href=\"#term-edge\"><span class=\"xref std std-term\">edge</span></a> connecting them.\nIf the edge is directed from <span class=\"math notranslate nohighlight\">\\(a\\)</span> to <span class=\"math notranslate nohighlight\">\\(b\\)</span>,\nthen we say that <span class=\"math notranslate nohighlight\">\\(a\\)</span> is adjacent to <span class=\"math notranslate nohighlight\">\\(b\\)</span>,\nand <span class=\"math notranslate nohighlight\">\\(b\\)</span> is adjacent from <span class=\"math notranslate nohighlight\">\\(a\\)</span>.</p>\n</dd>", "depth": "of the path from the root of the tree to <span class=\"math notranslate nohighlight\">\\(M\\)</span>.</p>\n</dd>", "NP-Complete": "If ever one such problem is proved to be solvable in\npolynomial time, or proved to require exponential time,\nthen all other NP-Complete problems will cost likewise.\nSince so many real-world problems have been proved to be\nNP-Complete, it would be extremely useful to determine if they\nhave polynomial or exponential cost. But so far, nobody has\nbeen able to determine the truth of the situation.\nA more technical definition is that a problem is NP-Complete if\nit is in NP and is NP-hard.</p>\n</dd>", "NP": "<a class=\"reference internal\" href=\"#term-non-deterministic-polynomial-time-algorithm\"><span class=\"xref std std-term\">non-deterministic polynomial</span></a>.</p>\n</dd>", "NP-hard": "That is, Problem X is NP-hard if any algorithm in NP can be\n<a class=\"reference internal\" href=\"#term-reduction\"><span class=\"xref std std-term\">reduced</span></a> to X in polynomial time.</p>\n</dd>", "clique": "defined as any <a class=\"reference internal\" href=\"#term-subset\"><span class=\"xref std std-term\">subset</span></a> <span class=\"math notranslate nohighlight\">\\(U\\)</span> of the graph\u2019s\n<a class=\"reference internal\" href=\"#term-vertex\"><span class=\"xref std std-term\">vertices</span></a> such that every vertex in <span class=\"math notranslate nohighlight\">\\(U\\)</span>\nhas an <a class=\"reference internal\" href=\"#term-edge\"><span class=\"xref std std-term\">edge</span></a> to every other vertex in <span class=\"math notranslate nohighlight\">\\(U\\)</span>.\nThe size of the clique is the number of vertices in the clique.</p>\n</dd>", "non-deterministic polynomial time algorithm": "(or might not) use <a class=\"reference internal\" href=\"#term-non-deterministic-choice\"><span class=\"xref std std-term\">non-deterministic choice</span></a>.</p>\n</dd>", "non-deterministic choice": "A nondeterministic choice can be viewed as either\n\u201ccorrectly guessing\u201d between a set of choices, or implementing\neach of the choices in parallel.\nIn the parallel view, the nondeterminism was successful if at\nleast one of the choices leads to a correct answer.</p>\n</dd>", "object": "takes up storage during the execution of a computer program.\nIn the <a class=\"reference internal\" href=\"#term-object-oriented-programming-paradigm\"><span class=\"xref std std-term\">object-oriented programming paradigm</span></a>, objects\nare the basic units of operation.\nObjects have state in the form of <a class=\"reference internal\" href=\"#term-data-member\"><span class=\"xref std std-term\">data members</span></a>,\nand they know how to perform certain actions\n(<a class=\"reference internal\" href=\"#term-method\"><span class=\"xref std std-term\">methods</span></a>).</p>\n</dd>", "object-oriented programming paradigm": "carried out using <a class=\"reference internal\" href=\"#term-object\"><span class=\"xref std std-term\">objects</span></a>.</p>\n</dd>", "cohesion": "a term that refers to the degree to which a class has a single\nwell-defined role or responsibility.</p>\n</dd>", "encapsulation": "from the user of an ADT, and protecting\n<a class=\"reference internal\" href=\"#term-data-member\"><span class=\"xref std std-term\">data members</span></a> of an\nobject from outside access.</p>\n</dd>", "polymorphism": "term meaning <em>one name, many forms</em>.\nIt describes the ability of software to change its behavior\ndynamically.  Two basic forms exist:\n<a class=\"reference internal\" href=\"#term-run-time-polymorphism\"><span class=\"xref std std-term\">run-time polymorphism</span></a> and <a class=\"reference internal\" href=\"#term-compile-time-polymorphism\"><span class=\"xref std std-term\">compile-time polymorphism</span></a>.</p>\n</dd>", "abstraction": "", "parser": "text (or more typically, the tokens from the <a class=\"reference internal\" href=\"#term-scanner\"><span class=\"xref std std-term\">scanner</span></a>),\nand verifies that the program is syntactically correct.\nTypically it will build a <a class=\"reference internal\" href=\"#term-parse-tree\"><span class=\"xref std std-term\">parse tree</span></a> as part of the\nprocess.</p>\n</dd>", "parse tree": "string, making it easy to compare against a <a class=\"reference internal\" href=\"#term-grammar\"><span class=\"xref std std-term\">grammar</span></a> to\nsee if it is syntactically correct.</p>\n</dd>", "vertex": "</dd>", "pointer": "</dd>", "variable": "", "address": "</dd>", "pointee": "<a class=\"reference internal\" href=\"#term-pointer\"><span class=\"xref std std-term\">pointer</span></a> or <a class=\"reference internal\" href=\"#term-reference\"><span class=\"xref std std-term\">reference</span></a>.</p>\n</dd>", "shallow copy": "value without copying the actual content.</p>\n</dd>", "dereference": "<a class=\"reference internal\" href=\"#term-reference\"><span class=\"xref std std-term\">reference</span></a> variable.\nCommonly, this happens in a language like Java when using the\n\u201cdot\u201d operator to access some field of an object.</p>\n</dd>", "initialization": "", "run-time polymorphism": "Overridden methods are those which implement a new method\nwith the same signature as a method inherited from its\n<a class=\"reference internal\" href=\"#term-base-class\"><span class=\"xref std std-term\">base class</span></a>.\nCompare to <a class=\"reference internal\" href=\"#term-compile-time-polymorphism\"><span class=\"xref std std-term\">compile-time polymorphism</span></a>.</p>\n</dd>", "RAM": "</dd>", "main memory": "In a computer, typically this will be <a class=\"reference internal\" href=\"#term-ram\"><span class=\"xref std std-term\">RAM</span></a>.</p>\n</dd>", "greedy algorithm": "</dd>", "Dijkstra's algorith": "", "proof": "</dd>", "NP-Completeness proof": "particular <a class=\"reference internal\" href=\"#term-problem\"><span class=\"xref std std-term\">problem</span></a> is <a class=\"reference internal\" href=\"#term-np-complete\"><span class=\"xref std std-term\">NP-complete</span></a>.\nSpecifically, an NP-Completeness proof must first show that the\nproblem is in class <a class=\"reference internal\" href=\"#term-np\"><span class=\"xref std std-term\">NP</span></a>, and then show (by using a\nreduction to another NP-Complete problem) that the problem is\n<a class=\"reference internal\" href=\"#term-np-hard\"><span class=\"xref std std-term\">NP-hard</span></a>.</p>\n</dd>", "proof by contradiction": "assuming that the theorem is false, and then uses a chain of\nreasoning to reach a logical contradiction.\nSince when the theorem is false a logical contradiction arises,\nthe conclusion is that the theorem must be true.</p>\n</dd>", "proof by induction": "It is used to prove a parameterized theorem $S(n)$, that is,\na theorem where there is a <a class=\"reference internal\" href=\"#term-induction-variable\"><span class=\"xref std std-term\">induction variable</span></a> involved\n(such as the sum of the numbers from 1 to $n$).\nOne first proves that the theorem holds true for a\n<a class=\"reference internal\" href=\"#term-base-case\"><span class=\"xref std std-term\">base case</span></a>, then one proves the implication that\nwhenever $S(n)$ is true then $S(n+1)$ is also true.\nAnother variation is <a class=\"reference internal\" href=\"#term-strong-induction\"><span class=\"xref std std-term\">strong induction</span></a>.</p>\n</dd>", "dequeue": "</dd>", "enqueue": "</dd>", "random access memory": "<a class=\"reference internal\" href=\"#term-primary-storage\"><span class=\"xref std std-term\">primary storage</span></a> in a modern computer.\nData access times are typically measured in billionths of a\nsecond (microseconds), which is roughly a million times faster\nthan data access from a disk drive.\nRAM is where data are held for immediate processing, since\naccess times are so much faster than for\n<a class=\"reference internal\" href=\"#term-secondary-storage\"><span class=\"xref std std-term\">secondary storage</span></a>.\nRAM is a typical part of a computer\u2019s <a class=\"reference internal\" href=\"#term-memory-hierarchy\"><span class=\"xref std std-term\">memory hierarchy</span></a>.</p>\n</dd>", "recursion": "An algorithm is recursive if it calls itself to do part of\nits work.\nSee <a class=\"reference internal\" href=\"#term-recursion\"><span class=\"xref std std-term\">recursion</span></a>.</p>\n</dd>", "recurrence relation": "recurrence) defines a function by means of an\nexpression that includes one or more (smaller) instances of\nitself.\nA classic example is the <a class=\"reference internal\" href=\"#term-recursion\"><span class=\"xref std std-term\">recursive</span></a>\ndefinition for the\nfactorial function, <span class=\"math notranslate nohighlight\">\\(F(n) = n*F(n-1)\\)</span>.</p>\n</dd>", "recursive function": "</dd>", "base case": "is the termination condition.\nThis is a simple input or value that can be solved (or proved in\nthe case of induction) without resorting to a recursive call\n(or the <a class=\"reference internal\" href=\"#term-induction-hypothesis\"><span class=\"xref std std-term\">induction hypothesis</span></a>).</p>\n</dd>", "recursive call": "function makes to itself.</p>\n</dd>", "binary search": "the <a class=\"reference internal\" href=\"#term-record\"><span class=\"xref std std-term\">record</span></a> with a given <a class=\"reference internal\" href=\"#term-search-key\"><span class=\"xref std std-term\">search key</span></a> value within\na sorted list.\nIt runs in <span class=\"math notranslate nohighlight\">\\(O(\\log n)\\)</span> time.\nAt each step, look at the middle of the current sublist, and throw\naway the half of the records whose keys are either too small or\ntoo large.</p>\n</dd>", "reference": "particular <a class=\"reference internal\" href=\"#term-data-item\"><span class=\"xref std std-term\">data item</span></a>.\nAn example might be a byte position within a file where the\nrecord is stored, or a pointer to a record in memory.\n(Note that Java makes a distinction between a reference and the\nconcept of a pointer, since it does not define a reference to\nnecessarily be a byte position in memory.)</p>\n</dd>", "Overriding": "", "runtime stack": "subroutine is called during a program\u2019s runtime.</p>\n</dd>", "scanner": "<a class=\"reference internal\" href=\"#term-lexical-analysis\"><span class=\"xref std std-term\">lexical analysis</span></a>.</p>\n</dd>", "search tree": "value more efficient.\nA type of <a class=\"reference internal\" href=\"#term-container\"><span class=\"xref std std-term\">container</span></a>, it is common to implement an\n<a class=\"reference internal\" href=\"#term-indexing\"><span class=\"xref std std-term\">index</span></a> using a search tree.\nA good search tree implementation will guarentee that insertion,\ndeletion, and search operations are all <span class=\"math notranslate nohighlight\">\\(\\Theta(\\log n)\\)</span>.</p>\n</dd>", "Binary Search Tree": "", "search trie": "</dd>", "alphabet trie": "strings.\nLevel <span class=\"math notranslate nohighlight\">\\(i\\)</span> of the tree corresponds to the letter in\nposition <span class=\"math notranslate nohighlight\">\\(i\\)</span> of the string.\nThe root will have potential branches on each intial letter of\nstring.\nThus, all strings starting with \u201ca\u201d will be stored in the \u201ca\u201d\nbranch of the tree.\nAt the second level, such strings will be separated by branching\non the second letter.</p>\n</dd>", "self-organizing list": "use of some <a class=\"reference internal\" href=\"#term-heuristic\"><span class=\"xref std std-term\">heuristic</span></a> to re-order its elements in an\neffort to improve search times.\nGenerally speaking, search is done sequentially from the\nbeginning, but the self-organizing heuristic will attempt to put\nthe records that are most likely to be searched for at or near\nthe front of the list.\nWhile typically not as efficient as <a class=\"reference internal\" href=\"#term-binary-search\"><span class=\"xref std std-term\">binary search</span></a> on a\nsorted list, self-organizing lists do not require that the list\nbe sorted (and so do not pay the cost of doing the sorting\noperation).</p>\n</dd>", "move-to-front": "<a class=\"reference internal\" href=\"#term-self-organizing-list\"><span class=\"xref std std-term\">self-organizing list</span></a>.\nUnder this heuristic, whenever a record is accessed it is moved\nto the front of the list.\nAnalogous to the <a class=\"reference internal\" href=\"#term-least-recently-used\"><span class=\"xref std std-term\">least recently used</span></a> heuristic for\nmaintaining a <a class=\"reference internal\" href=\"#term-buffer-pool\"><span class=\"xref std std-term\">buffer pool</span></a>.</p>\n</dd>", "transpose": "the transpose of a matrix <span class=\"math notranslate nohighlight\">\\(A\\)</span> is\nanother matrix <span class=\"math notranslate nohighlight\">\\(A^T\\)</span> created by writing the rows of\n<span class=\"math notranslate nohighlight\">\\(A\\)</span> as the columns of <span class=\"math notranslate nohighlight\">\\(A^T\\)</span>.\nIn the context of a <a class=\"reference internal\" href=\"#term-self-organizing-list\"><span class=\"xref std std-term\">self-organizing list</span></a>,\ntranspose is a <a class=\"reference internal\" href=\"#term-heuristic\"><span class=\"xref std std-term\">heuristic</span></a> used to maintain the list.\nUnder this heuristic, whenever a record is accessed it is moved\none position closer to the front of the list.</p>\n</dd>", "deserialization": "representation for a data structure back to its original\nin-memory form.</p>\n</dd>", "sequential tree representation": "minimum information needed to reconstruct the tree structure.\nThis is a technique for <a class=\"reference internal\" href=\"#term-serialization\"><span class=\"xref std std-term\">serializing</span></a> a\ntree.</p>\n</dd>", "boolean": "", "integer": "", "singly linked list": "node contains access an pointer only to the next element in the list.</p>\n</dd>", "one-way list": "</dd>", "spatial data structure": "processing when a\n<a class=\"reference internal\" href=\"#term-spatial-attribute\"><span class=\"xref std std-term\">spatial attribute</span></a> is used as the key.\nIn particular, a data structure that supports efficient search\nby location, or finds all records within a given region in two\nor more dimensions.\nExamples of spatial data structures to store point data include\nthe <a class=\"reference internal\" href=\"#term-bintree\"><span class=\"xref std std-term\">bintree</span></a>, the <a class=\"reference internal\" href=\"#term-pr-quadtree\"><span class=\"xref std std-term\">PR quadtree</span></a> and the\n<a class=\"reference internal\" href=\"#term-kd-tree\"><span class=\"xref std std-term\">kd tree</span></a>.</p>\n</dd>", "PR quadtree": "dimensions.\nThe root of the PR quadtree represents some square region of 2d\nspace.\nIf that space stores more than one data point, then the region\nis decomposed into four equal subquadrants, each represented\n<a class=\"reference internal\" href=\"#term-recursion\"><span class=\"xref std std-term\">recursively</span></a> by a subtree of the PR quadtree.\nSince many leaf nodes of the PR quadtree will contain no data\npoints, implementation often makes use of the <a class=\"reference internal\" href=\"#term-flyweight\"><span class=\"xref std std-term\">Flyweight</span></a>\n<a class=\"reference internal\" href=\"#term-design-pattern\"><span class=\"xref std std-term\">design pattern</span></a>.\nRelated to the <a class=\"reference internal\" href=\"#term-bintree\"><span class=\"xref std std-term\">bintree</span></a>.</p>\n</dd>", "Splay Tree": "the standard BST in that it uses modified insert and remove\nmethods in order to keep the tree\n<a class=\"reference internal\" href=\"#term-balanced-tree\"><span class=\"xref std std-term\">balanced</span></a>.\nSimilar to an <a class=\"reference internal\" href=\"#term-avl-tree\"><span class=\"xref std std-term\">AVL Tree</span></a> in that it uses the concept of\n<a class=\"reference internal\" href=\"#term-rotation\"><span class=\"xref std std-term\">rotations</span></a> in the insert and remove operations.\nWhile a Splay Tree does not guarentee that the tree is balanced,\nit does guarentee that a series of <span class=\"math notranslate nohighlight\">\\(n\\)</span> operations on the\ntree will have a total cost of <span class=\"math notranslate nohighlight\">\\(\\Theta(n \\log n)\\)</span> cost,\nmeaning that any given operation can be viewed as having\n<a class=\"reference internal\" href=\"#term-amortized-cost\"><span class=\"xref std std-term\">amortized cost</span></a> of <span class=\"math notranslate nohighlight\">\\(\\Theta(\\log n)\\)</span>.</p>\n</dd>", "splaying": "<a class=\"reference internal\" href=\"#term-splay-tree\"><span class=\"xref std std-term\">Splay Tree</span></a>.</p>\n</dd>", "push": "onto a <a class=\"reference internal\" href=\"#term-stack\"><span class=\"xref std std-term\">stack</span></a>.</p>\n</dd>", "pop": "from a <a class=\"reference internal\" href=\"#term-stack\"><span class=\"xref std std-term\">stack</span></a>.</p>\n</dd>", "subgraph": "<span class=\"math notranslate nohighlight\">\\(\\mathbf{G}\\)</span> by selecting a <a class=\"reference internal\" href=\"#term-subset\"><span class=\"xref std std-term\">subset</span></a>\n<span class=\"math notranslate nohighlight\">\\(\\mathbf{V}_s\\)</span> of <span class=\"math notranslate nohighlight\">\\(\\mathbf{G}\\)</span>\u2019s <a class=\"reference internal\" href=\"#term-vertex\"><span class=\"xref std std-term\">vertices</span></a> and a subset <span class=\"math notranslate nohighlight\">\\(\\mathbf{E}_s\\)</span> of\n<span class=\"math notranslate nohighlight\">\\(\\mathbf{G}\\)</span>\u2019s <a class=\"reference internal\" href=\"#term-edge\"><span class=\"xref std std-term\">edges</span></a> such that for every\nedge <span class=\"math notranslate nohighlight\">\\(e \\in \\mathbf{E}_s\\)</span>,\nboth vertices of <span class=\"math notranslate nohighlight\">\\(e\\)</span> are in <span class=\"math notranslate nohighlight\">\\(\\mathbf{V}_s\\)</span>.</p>\n</dd>", "tokens": "", "trie": "a split in the <a class=\"reference internal\" href=\"#term-key-space\"><span class=\"xref std std-term\">key space</span></a> at a predetermined location,\nrather than split based on the actual <a class=\"reference internal\" href=\"#term-key\"><span class=\"xref std std-term\">key</span></a> values seen.\nFor example, a simple binary search trie for key values in the\nrange 0 to 1023 would store all records with key values less\nthan 512 on the left side of the tree, and all records with key\nvalues equal to or greater than 512 on the right side of the\ntree.\nA trie is always a <a class=\"reference internal\" href=\"#term-full-tree\"><span class=\"xref std std-term\">full tree</span></a>.\nFolklore has it that the term comes from \u201cretrieval\u201d, and should\nbe pronounced as \u201ctry\u201d (in contrast to \u201ctree\u201d, to distinguish\nthe differences in the space decomposition method of a search\ntree versus a search trie).\nThe term \u201ctrie\u201d is also sometimes used as a synonym for the\n<a class=\"reference internal\" href=\"#term-alphabet-trie\"><span class=\"xref std std-term\">alphabet trie</span></a>.</p>\n</dd>", "alphebet trie": "", "variable-length coding": "assigns a code to each object in the collection using codes that\ncan be of different lengths.\nTypically this is done in a way such that the objects that are\nmost likely to be used have the shortest codes, with the goal of\nminimizing the total space needed to represent a sequence of\nobjects, such as when representing the characters in a document.\n<a class=\"reference internal\" href=\"#term-huffman-codes\"><span class=\"xref std std-term\">Huffman coding</span></a> is an example of a\nvariable-length coding scheme.\nThis is in contrast to <a class=\"reference internal\" href=\"#term-fixed-length-coding\"><span class=\"xref std std-term\">fixed-length coding</span></a>.</p>\n</dd>", "Huffman codes": "through the process of Huffman coding.\nHuffman coding uses a <a class=\"reference internal\" href=\"#term-huffman-coding-tree\"><span class=\"xref std std-term\">Huffman coding tree</span></a> to generate\nthe codes.\nThe codes can be of variable length, such that the letters which\nare expected to appear most frequently are shorter.\nHuffman coding is optimal whenever the true frequencies are\nknown, and the frequency of a letter is independent of the\ncontext of that letter in the message.</p>\n</dd>", "fixed-length coding": "assigns a code to each object in the collection using codes that\nare all of the same length.\nStandard ASCII and Unicode representations for characters are\nboth examples of fixed-length coding schemes.\nThis is in contrast to <a class=\"reference internal\" href=\"#term-variable-length-coding\"><span class=\"xref std std-term\">variable-length coding</span></a>.</p>\n</dd>", "vector": "As a data structure, the term vector usually used as a snyonym\nfor a <a class=\"reference internal\" href=\"#term-dynamic-array\"><span class=\"xref std std-term\">dynamic array</span></a>.</p>\n</dd>", "sequence": "which may contain duplicate-valued elements.\nA sequence is also sometimes called a <a class=\"reference internal\" href=\"#term-tuple\"><span class=\"xref std std-term\">tuple</span></a> or a\n<a class=\"reference internal\" href=\"#term-vector\"><span class=\"xref std std-term\">vector</span></a>.</p>\n</dd>", "dynamic array": "an <a class=\"reference internal\" href=\"#term-interface\"><span class=\"xref std std-term\">interface</span></a> around the array so as to appear to allow the array\nto grow and shrink in size as necessary. Typically this is done\nby allocating a new copy, copying the contents of the old array,\nand then returning the old array to <a class=\"reference internal\" href=\"#term-free-store\"><span class=\"xref std std-term\">free store</span></a>.\nIf done correctly, the <a class=\"reference internal\" href=\"#term-amortized-cost\"><span class=\"xref std std-term\">amortized cost</span></a> for dynamically\nresizing the array can be made constant.\nIn some programming languages such as Java, the term\n<a class=\"reference internal\" href=\"#term-vector\"><span class=\"xref std std-term\">vector</span></a> is used as a synonym for dynamic array.</p>\n</dd>"}, "linking_phrase": {"has": " has", "formof": " form of\n", "abbreviation": " abbreviation", "logicallydefines": " logically defines\n", "stores": " stores", "types": " types", "hasno": " has no\n", "synonym": " synonym", "solves": " solves", "implementedby": " implemented by\n", "keyconcept": " key concept", "formalsynonym": " formal synonym\n", "solvedby": " solved by", "is": " is", "usedin": " used in", "uses": " uses", "analogousto": " analogous to", "implementing": " implementing\n", "operations": " operations", "isa": " is a", "variant": " variant\n", "raises": " raises", "example": " example", "abbreviated": " abbreviated\n", "typeof": " type of", "composedof": " composed of", "operation": " operation\n", "caninclude": " can include", "changes": " changes", "performs": " performs", "phase": " phase", "knownas": " known as", "concept": " concept", "implements": " implements\n", "type": " type\n", "generates": " generates\n", "exampleof": " example of", "Read/write": " Read/write\n", "uniteofstorage": " unite of storage\n", "uniteofspace": " unite of space\n", "consistsof": " consists of\n", "contains": " contains", "problems": " problems\n", "conceptof": " concept of\n", "walksthrough": " walks through", "produces": " produces\n", "exampleuse": " example use", "storagetype": " storage type", "algorithms": " algorithms", "neverhave": " never have\n", "context": " context\n", "linkedto": " linked to", "createdby": " created by\n", "property": " property\n", "exampleproblem": " example problem\n", "instanceof": " instance of", "principle": " principle\n", "partof": " part of", "build": " build\n", "In": " In", "sequenceof": " sequence of\n", "value": " value\n", "pointto": " point to\n", "defaultcopy": " default copy\n", "getpointeevalue": " get pointee value\n", "requires": " requires\n", "form": " form", "identicalto": " identical to\n", "abbreviationfor": " abbreviation for", "expressedas": " expressed as", "implementedin": " implemented in\n", "includes": " includes", "similarto": " similar to", "ifnotinitialized": " if not initialized\n", "Knownas": " Known as", "responsiblefor": " responsible for\n", "heuristic": " heuristic", "reversedby": " reversed by", "accepts": " accepts\n", "contrastto": " contrast to\n"}, "connections": {"con-1": {"from": "2-3 tree", "to": "binary search tree property", "label": " has"}, "con-2": {"from": "2-3 tree", "to": "B-tree", "label": " form of\n"}, "con-3": {"from": "abstract data type", "to": "ADT", "label": " abbreviation"}, "con-4": {"from": "abstract data type", "to": "interface", "label": " logically defines\n"}, "con-5": {"from": "activation record", "to": "local variable", "label": " stores"}, "con-6": {"from": "acyclic graph", "to": "directed acyclic graph", "label": " types"}, "con-7": {"from": "acyclic graph", "to": "cycles <cycle>", "label": " has no\n"}, "con-8": {"from": "aggregate type", "to": "composite type", "label": " synonym"}, "con-9": {"from": "aggregate type", "to": "member", "label": " has\n"}, "con-10": {"from": "algorithm", "to": "problem", "label": " solves"}, "con-11": {"from": "algorithm", "to": "program", "label": " implemented by\n"}, "con-12": {"from": "algorithm analysis", "to": "growth rate", "label": " key concept"}, "con-13": {"from": "algorithm analysis", "to": "upper bound", "label": " key concept\n"}, "con-14": {"from": "algorithm analysis", "to": "lower bound", "label": " key concept\n"}, "con-15": {"from": "algorithm analysis", "to": "asymptotic analysis", "label": " synonym\n"}, "con-16": {"from": "algorithm analysis", "to": "asymptotic algorithm analysis", "label": " formal synonym\n"}, "con-17": {"from": "all-pairs shortest paths problem", "to": "Floyd's algorithm", "label": " solved by"}, "con-18": {"from": "amortized analysis", "to": "algorithm analysis", "label": " is"}, "con-19": {"from": "amortized cost", "to": "amortized analysis", "label": " used in"}, "con-20": {"from": "array-based list", "to": "array", "label": " uses"}, "con-21": {"from": "array-based stack", "to": "array-based list", "label": " analogous to"}, "con-22": {"from": "array-based stack", "to": "stack", "label": " implementing\n"}, "con-23": {"from": "array-based queue", "to": "array-based list", "label": " analogous to"}, "con-24": {"from": "array-based queue", "to": "queue", "label": " implementing\n"}, "con-25": {"from": "assembly code", "to": "intermediate code", "label": " form of"}, "con-26": {"from": "asymptotic analysis", "to": "algorithm analysis", "label": " synonym"}, "con-27": {"from": "asymptotic analysis", "to": "asymptotic algorithm analysis", "label": " formal synonym\n"}, "con-28": {"from": "AVL Tree", "to": "double rotation", "label": " operations"}, "con-29": {"from": "AVL Tree", "to": "single rotation", "label": " operations\n"}, "con-30": {"from": "B-tree", "to": "balanced tree", "label": " is a"}, "con-31": {"from": "B-tree", "to": "B$^+$-tree", "label": " variant\n"}, "con-32": {"from": "B-tree", "to": "B$^*$-tree", "label": " variant\n"}, "con-33": {"from": "bad reference", "to": "NullPointerException", "label": " raises"}, "con-34": {"from": "bag", "to": "multilist", "label": " synonym"}, "con-35": {"from": "binary search tree", "to": "AVL tree", "label": " example"}, "con-36": {"from": "binary search tree", "to": "binary search tree property", "label": " has\n"}, "con-37": {"from": "binary search tree", "to": "BST", "label": " abbreviated\n"}, "con-38": {"from": "binary search tree", "to": "splay tree", "label": " example\n"}, "con-39": {"from": "binary tree", "to": "binary search tree", "label": " example"}, "con-40": {"from": "binary tree", "to": "binary trie", "label": " example\n"}, "con-41": {"from": "binary tree", "to": "complete binary tree", "label": " example\n"}, "con-42": {"from": "binary tree", "to": "bintree", "label": " example\n"}, "con-43": {"from": "bintree", "to": "flyweight", "label": " uses"}, "con-44": {"from": "breadth-first search", "to": "BFS", "label": " abbreviation"}, "con-45": {"from": "bubble sort", "to": "algorithm", "label": " type of"}, "con-46": {"from": "bucket hashing", "to": "bucket", "label": " uses"}, "con-47": {"from": "buffer", "to": "dirty bit", "label": " uses"}, "con-48": {"from": "buffer pool", "to": "buffer", "label": " composed of"}, "con-49": {"from": "buffer pool", "to": "flush", "label": " operation\n"}, "con-50": {"from": "caching", "to": "buffering", "label": " synonym"}, "con-51": {"from": "class", "to": "member function", "label": " can include"}, "con-52": {"from": "class", "to": "data member", "label": " can include\n"}, "con-53": {"from": "closed hash system", "to": "open addressing", "label": " synonym"}, "con-54": {"from": "code optimization", "to": "assembly code", "label": " changes"}, "con-55": {"from": "collision resolution policy", "to": "collision resolution", "label": " performs"}, "con-56": {"from": "compiler", "to": "lexical analysis", "label": " phase"}, "con-57": {"from": "compiler", "to": "syntax analysis", "label": " phase\n"}, "con-58": {"from": "compiler", "to": "intermediate code generation", "label": " phase\n"}, "con-59": {"from": "compiler", "to": "code optimization", "label": " phase\n"}, "con-60": {"from": "compiler", "to": "code generation", "label": " phase\n"}, "con-61": {"from": "compile-time polymorphism", "to": "Overloading", "label": " known as"}, "con-62": {"from": "cycle", "to": "path", "label": " is"}, "con-63": {"from": "cycle", "to": "simple cycle", "label": " example\n"}, "con-64": {"from": "data item", "to": "data member", "label": " implemented by"}, "con-65": {"from": "data member", "to": "data field", "label": " synonym"}, "con-66": {"from": "data member", "to": "attribute", "label": " synonym\n"}, "con-67": {"from": "data member", "to": "instance variable", "label": " synonym\n"}, "con-68": {"from": "data structure", "to": "serialization", "label": " concept"}, "con-69": {"from": "data structure", "to": "abstract data type", "label": " implements\n"}, "con-70": {"from": "data type", "to": "abstract data type", "label": " implemented by"}, "con-71": {"from": "data type", "to": "aggregate type", "label": " type\n"}, "con-72": {"from": "data type", "to": "simple type", "label": " type\n"}, "con-73": {"from": "data type", "to": "list", "label": " example\n"}, "con-74": {"from": "data type", "to": "array", "label": " example\n"}, "con-75": {"from": "depth-first search", "to": "DFS", "label": " abbreviation"}, "con-76": {"from": "depth-first search", "to": "depth-first search tree", "label": " generates\n"}, "con-77": {"from": "design pattern", "to": "Composite design pattern", "label": " example"}, "con-78": {"from": "design pattern", "to": "flyweight", "label": " example\n"}, "con-79": {"from": "design pattern", "to": "strategy", "label": " example\n"}, "con-80": {"from": "design pattern", "to": "visitor", "label": " example\n"}, "con-81": {"from": "directed acyclic graph", "to": "DAG", "label": " abbreviation"}, "con-82": {"from": "directed graph", "to": "directed acyclic graph", "label": " types"}, "con-83": {"from": "directed graph", "to": "digraph", "label": " abbreviation\n"}, "con-84": {"from": "disk drive", "to": "peripheral storage", "label": " example of"}, "con-85": {"from": "disk drive", "to": "disk I/O", "label": " Read/write\n"}, "con-86": {"from": "disk drive", "to": "block", "label": " unite of storage\n"}, "con-87": {"from": "disk drive", "to": "sector", "label": " unite of space\n"}, "con-88": {"from": "dynamic allocation", "to": "node", "label": " example"}, "con-89": {"from": "dynamic programming", "to": "Floyd's algorithm", "label": " example"}, "con-90": {"from": "Finite Automata", "to": "state machine", "label": " synonym"}, "con-91": {"from": "Finite Automata", "to": "states", "label": " consists of\n"}, "con-92": {"from": "Finite Automata", "to": "accepting states <accepting states>", "label": " consists of\n"}, "con-93": {"from": "Finite Automata", "to": "Deterministic Finite Automata", "label": " example\n"}, "con-94": {"from": "Floyd's algorithm", "to": "k-path", "label": " uses"}, "con-95": {"from": "graph", "to": "edges <edge>", "label": " contains"}, "con-96": {"from": "graph", "to": "vertices <vertex>", "label": " contains\n"}, "con-97": {"from": "graph", "to": "adjacency matrix", "label": " implemented by\n"}, "con-98": {"from": "graph", "to": "adjacency list", "label": " implemented by\n"}, "con-99": {"from": "graph", "to": "traversal", "label": " problems\n"}, "con-100": {"from": "graph", "to": "topological sort", "label": " problems\n"}, "con-101": {"from": "graph", "to": "shortest paths", "label": " problems\n"}, "con-102": {"from": "graph", "to": "dense graph", "label": " types\n"}, "con-103": {"from": "graph", "to": "sparse graph", "label": " types\n"}, "con-104": {"from": "graph", "to": "directed graph", "label": " types\n"}, "con-105": {"from": "graph", "to": "acyclic graph", "label": " types\n"}, "con-106": {"from": "graph", "to": "labeled graph", "label": " types\n"}, "con-107": {"from": "graph", "to": "undirected graph", "label": " types\n"}, "con-108": {"from": "graph", "to": "weighted graph", "label": " types\n"}, "con-109": {"from": "graph", "to": "unweighted graph", "label": " types\n"}, "con-110": {"from": "growth rate", "to": "lower bound", "label": " type"}, "con-111": {"from": "growth rate", "to": "upper bound", "label": " type\n"}, "con-112": {"from": "hash system", "to": "hash function", "label": " uses"}, "con-113": {"from": "hash system", "to": "bucket hashing", "label": " type\n"}, "con-114": {"from": "hash system", "to": "closed hash system", "label": " type\n"}, "con-115": {"from": "hash system", "to": "open hash system", "label": " type\n"}, "con-116": {"from": "hashing", "to": "hash table", "label": " has"}, "con-117": {"from": "hashing", "to": "hash function", "label": " has\n"}, "con-118": {"from": "hashing", "to": "collision resolution policy", "label": " has\n"}, "con-119": {"from": "heap", "to": "complete binary tree", "label": " is"}, "con-120": {"from": "heap", "to": "priority queue", "label": " used in\n"}, "con-121": {"from": "heap", "to": "max heap", "label": " example\n"}, "con-122": {"from": "heap", "to": "min heap", "label": " example\n"}, "con-123": {"from": "heapsort", "to": "replacement selection", "label": " variant"}, "con-124": {"from": "heapsort", "to": "heap", "label": " concept of\n"}, "con-125": {"from": "inherit", "to": "base class", "label": " has"}, "con-126": {"from": "inherit", "to": "subclass", "label": " has\n"}, "con-127": {"from": "intermediate code generation", "to": "Parse tree", "label": " walks through"}, "con-128": {"from": "intermediate code generation", "to": "intermediate code", "label": " produces\n"}, "con-129": {"from": "kd tree", "to": "discriminator", "label": " uses"}, "con-130": {"from": "key", "to": "key space", "label": " has"}, "con-131": {"from": "key sort", "to": "key", "label": " uses"}, "con-132": {"from": "key-space decomposition", "to": "object-space decomposition", "label": " type"}, "con-133": {"from": "key-space decomposition", "to": "image-space decomposition", "label": " type\n"}, "con-134": {"from": "Kruskal's algorithm", "to": "UNION/FIND", "label": " uses"}, "con-135": {"from": "lexical analysis", "to": "interpreter", "label": " is"}, "con-136": {"from": "list", "to": "array-based list", "label": " implements"}, "con-137": {"from": "list", "to": "linked list", "label": " implements\n"}, "con-138": {"from": "local variable", "to": "automatic variable", "label": " synonym"}, "con-139": {"from": "local variable", "to": "stack variable", "label": " synonym\n"}, "con-140": {"from": "locality of reference", "to": "80/20 rule", "label": " example use"}, "con-141": {"from": "lower bounds proof", "to": "adversary argument", "label": " example"}, "con-142": {"from": "lower bounds proof", "to": "sorting lower bound", "label": " example\n"}, "con-143": {"from": "lower bounds proof", "to": "search lower bound", "label": " example\n"}, "con-144": {"from": "member", "to": "element", "label": " synonym"}, "con-145": {"from": "memory hierarchy", "to": "primary storage", "label": " storage type"}, "con-146": {"from": "memory hierarchy", "to": "secondary storage", "label": " storage type\n"}, "con-147": {"from": "memory manager", "to": "buddy method", "label": " example"}, "con-148": {"from": "minimal-cost spanning tree", "to": "Kruskal's algorithm", "label": " algorithms"}, "con-149": {"from": "minimal-cost spanning tree", "to": "Prim's algorithm", "label": " algorithms\n"}, "con-150": {"from": "minimal-cost spanning tree", "to": "MCST", "label": " abbreviation\n"}, "con-151": {"from": "minimal-cost spanning tree", "to": "MST", "label": " abbreviation\n"}, "con-152": {"from": "minimal-cost spanning tree", "to": "cycle", "label": " never have\n"}, "con-153": {"from": "minimal-cost spanning tree", "to": "tree", "label": " is a\n"}, "con-154": {"from": "modulus", "to": "mod", "label": " abbreviation"}, "con-155": {"from": "multi-dimensional search structure", "to": "multi-dimensional search key", "label": " uses"}, "con-156": {"from": "multilist", "to": "bag", "label": " synonym"}, "con-157": {"from": "neighbor", "to": "adjacent", "label": " is"}, "con-158": {"from": "neighbor", "to": "graph", "label": " context\n"}, "con-159": {"from": "node", "to": "neighbor", "label": " linked to"}, "con-160": {"from": "node", "to": "dynamic allocation", "label": " created by\n"}, "con-161": {"from": "node", "to": "depth", "label": " property\n"}, "con-162": {"from": "NP-Complete", "to": "NP", "label": " is"}, "con-163": {"from": "NP-Complete", "to": "NP-hard", "label": " is\n"}, "con-164": {"from": "NP-Complete", "to": "clique", "label": " example problem\n"}, "con-165": {"from": "non-deterministic polynomial time algorithm", "to": "NP", "label": " abbreviation"}, "con-166": {"from": "non-deterministic polynomial time algorithm", "to": "non-deterministic choice", "label": " operation\n"}, "con-167": {"from": "object", "to": "class", "label": " instance of"}, "con-168": {"from": "object-oriented programming paradigm", "to": "cohesion", "label": " key concept"}, "con-169": {"from": "object-oriented programming paradigm", "to": "inherit", "label": " principle\n"}, "con-170": {"from": "object-oriented programming paradigm", "to": "encapsulation", "label": " principle\n"}, "con-171": {"from": "object-oriented programming paradigm", "to": "polymorphism", "label": " principle\n"}, "con-172": {"from": "object-oriented programming paradigm", "to": "abstraction", "label": " principle\n"}, "con-173": {"from": "object-oriented programming paradigm", "to": "object", "label": " consists of\n"}, "con-174": {"from": "parser", "to": "compiler", "label": " part of"}, "con-175": {"from": "parser", "to": "parse tree", "label": " build\n"}, "con-176": {"from": "path", "to": "tree", "label": " In"}, "con-177": {"from": "path", "to": "vertex", "label": " sequence of\n"}, "con-178": {"from": "pointer", "to": "variable", "label": " is a"}, "con-179": {"from": "pointer", "to": "address", "label": " value\n"}, "con-180": {"from": "pointer", "to": "binary tree", "label": " used in\n"}, "con-181": {"from": "pointer", "to": "linked list", "label": " used in\n"}, "con-182": {"from": "pointer", "to": "pointee", "label": " point to\n"}, "con-183": {"from": "pointer", "to": "shallow copy", "label": " default copy\n"}, "con-184": {"from": "pointer", "to": "dereference", "label": " get pointee value\n"}, "con-185": {"from": "pointer", "to": "initialization", "label": " requires\n"}, "con-186": {"from": "polymorphism", "to": "run-time polymorphism", "label": " form"}, "con-187": {"from": "polymorphism", "to": "compile-time polymorphism", "label": " form\n"}, "con-188": {"from": "pointee", "to": "array", "label": " example"}, "con-189": {"from": "pointee", "to": "object", "label": " example\n"}, "con-190": {"from": "primary storage", "to": "RAM", "label": " example"}, "con-191": {"from": "primary storage", "to": "main memory", "label": " synonym\n"}, "con-192": {"from": "Prim's algorithm", "to": "greedy algorithm", "label": " is a"}, "con-193": {"from": "Prim's algorithm", "to": "Dijkstra's algorith", "label": " identical to\n"}, "con-194": {"from": "proof", "to": "lower bounds proof", "label": " example"}, "con-195": {"from": "proof", "to": "NP-Completeness proof", "label": " example\n"}, "con-196": {"from": "proof", "to": "proof by contradiction", "label": " type\n"}, "con-197": {"from": "proof", "to": "proof by induction", "label": " type\n"}, "con-198": {"from": "queue", "to": "dequeue", "label": " operations"}, "con-199": {"from": "queue", "to": "enqueue", "label": " operations\n"}, "con-200": {"from": "RAM", "to": "random access memory", "label": " abbreviation for"}, "con-201": {"from": "recursion", "to": "recurrence relation", "label": " expressed as"}, "con-202": {"from": "recursion", "to": "recursive function", "label": " implemented in\n"}, "con-203": {"from": "recursive function", "to": "base case", "label": " includes"}, "con-204": {"from": "recursive function", "to": "recursive call", "label": " includes\n"}, "con-205": {"from": "recursive function", "to": "binary search", "label": " example\n"}, "con-206": {"from": "reference", "to": "pointer", "label": " similar to"}, "con-207": {"from": "reference", "to": "bad reference", "label": " if not initialized\n"}, "con-208": {"from": "run-time polymorphism", "to": "Overriding", "label": " Known as"}, "con-209": {"from": "runtime stack", "to": "activation record", "label": " composed of"}, "con-210": {"from": "scanner", "to": "compiler", "label": " part of"}, "con-211": {"from": "scanner", "to": "lexical analysis", "label": " responsible for\n"}, "con-212": {"from": "search tree", "to": "Binary Search Tree", "label": " example"}, "con-213": {"from": "search tree", "to": "2-3 tree", "label": " example\n"}, "con-214": {"from": "search tree", "to": "B-tree", "label": " example\n"}, "con-215": {"from": "search tree", "to": "search trie", "label": " example\n"}, "con-216": {"from": "search trie", "to": "alphabet trie", "label": " example"}, "con-217": {"from": "search trie", "to": "binary trie", "label": " example\n"}, "con-218": {"from": "secondary storage", "to": "disk drive", "label": " example"}, "con-219": {"from": "self-organizing list", "to": "move-to-front", "label": " heuristic"}, "con-220": {"from": "self-organizing list", "to": "transpose", "label": " heuristic\n"}, "con-221": {"from": "serialization", "to": "deserialization", "label": " reversed by"}, "con-222": {"from": "serialization", "to": "sequential tree representation", "label": " example\n"}, "con-223": {"from": "simple type", "to": "boolean", "label": " example of"}, "con-224": {"from": "simple type", "to": "integer", "label": " example of\n"}, "con-225": {"from": "singly linked list", "to": "one-way list", "label": " synonym"}, "con-226": {"from": "spatial data structure", "to": "bintree", "label": " example"}, "con-227": {"from": "spatial data structure", "to": "kd tree", "label": " example\n"}, "con-228": {"from": "spatial data structure", "to": "PR quadtree", "label": " example\n"}, "con-229": {"from": "Splay Tree", "to": "splaying", "label": " operation"}, "con-230": {"from": "stack", "to": "push", "label": " operations"}, "con-231": {"from": "stack", "to": "pop", "label": " operations\n"}, "con-232": {"from": "subgraph", "to": "clique", "label": " example"}, "con-233": {"from": "syntax analysis", "to": "parse tree", "label": " generates"}, "con-234": {"from": "syntax analysis", "to": "tokens", "label": " accepts\n"}, "con-235": {"from": "trie", "to": "alphebet trie", "label": " example"}, "con-236": {"from": "trie", "to": "binary trie", "label": " example\n"}, "con-237": {"from": "trie", "to": "search trie", "label": " example\n"}, "con-238": {"from": "variable-length coding", "to": "Huffman codes", "label": " example"}, "con-239": {"from": "variable-length coding", "to": "fixed-length coding", "label": " contrast to\n"}, "con-240": {"from": "vector", "to": "sequence", "label": " synonym"}, "con-241": {"from": "vector", "to": "dynamic array", "label": " synonym\n"}, "con-242": {"from": "vertex", "to": "node", "label": " synonym"}}}