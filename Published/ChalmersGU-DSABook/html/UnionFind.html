
<!DOCTYPE html>




<html lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>6.2. The Union/Find Algorithm (optional) &mdash; Data Structures and Algorithms</title>
    
    <link rel="stylesheet" href="_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../lib/normalize.css" type="text/css" />
    <link rel="stylesheet" href="../../../lib/JSAV.css" type="text/css" />
    <link rel="stylesheet" href="../../../lib/odsaMOD-min.css" type="text/css" />
    <link rel="stylesheet" href="../../../lib/jquery.ui.min.css" type="text/css" />
    <link rel="stylesheet" href="../../../lib/odsaStyle-min.css" type="text/css" />
    <link rel="stylesheet" href="../../../lib/accessibility.css" type="text/css" />
    
  <script type="text/javascript">
    var DOCUMENTATION_OPTIONS = {
      URL_ROOT:    './',
      VERSION:     '0.4.1',
      COLLAPSE_INDEX: false,
      FILE_SUFFIX: '.html',
      HAS_SOURCE:  true
    };
  </script>

  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
        processEscapes: true
      },
      "HTML-CSS": {
        scale: "80"
      }
    });
  </script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="index" title="Data Structures and Algorithms" href="index.html" />
    <link rel="next" title="3. Sequential Tree Representations (optional)" href="SequentialRep.html" />
    <link rel="prev" title="1. General Trees (optional)" href="GenTreeIntro.html" />

  </head>

  <body>


      <div class="header">
        
  
      <script type="text/javascript" src="../../../lib/jquery.min.js"></script>
      <script type="text/javascript" src="../../../lib/jquery.migrate.min.js"></script>
      <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
      <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/localforage/1.9.0/localforage.min.js"></script>
      <script type="text/javascript" src="../../../lib/accessibility.js"></script>
    <script type="text/javascript" src="../../../lib/jquery.ui.min.js"></script>
    <script type="text/javascript" src="../../../lib/jquery.transit.js"></script>
    <script type="text/javascript" src="../../../lib/raphael.js"></script>
    <script type="text/javascript" src="../../../lib/JSAV-min.js"></script>
    <script type="text/javascript" src="_static/config.js"></script>
    <script type="text/javascript" src="../../../lib/timeme-min.js"></script>
    <script type="text/javascript" src="../../../lib/odsaUtils-min.js"></script>
    <script type="text/javascript" src="../../../lib/odsaMOD-min.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/d3/4.13.0/d3.min.js"></script>
    <script type="text/javascript" src="https://d3js.org/d3-selection-multi.v1.min.js"></script>
    <script type="text/javascript" src="../../../lib/dataStructures.js"></script>
    <script type="text/javascript" src="../../../lib/conceptMap.js"></script>

        
<a id="username-link" style="float:right;color:red;margin:10px 20px auto; display: none" class="username-link" href="Gradebook.html"></a>
<a id="login-link" style="float:right;color:red;margin:10px 20px auto" class="login-link" href="#"><Macro 'login'></a>
<div id="login-box" class="login-popup">
  <a href="#" class="close"><img src="_static/Images/close_pop.png" class="btn_close" title="Close Window" alt="Close" /></a>
  <form method="post" class="signin" action="https://#">
    <fieldset class="textbox">
      <label class="username">
        <span>Username</span>
        <input id="username" value="" type="text" autocomplete="on" placeholder="Username" tabindex="1">
      </label>
      <label class="password">
        <span>Password</span>
        <input id="password" value="" type="password" placeholder="Password" tabindex="2">
        <span><a id="forgot" href="#">Forgot your password?</a></span>
      </label>

      <p>
        <input type="submit" id="login-submit-button" value="Sign in" tabindex="3" />
      </p>
      <p>
        <input type="button" id="register-button" value="Register" tabindex="4" />
      </p>
    </fieldset>
  </form>
</div>

        
<a id="registration-link" style="float:right;color:red;margin:10px 20px auto" class="registration-link" href="#">Register</a>
<div id="registration-box" class="registration-popup ">
  <a href="#" class="close"><img src="_static/Images/close_pop.png" class="btn_close" title="Close Window" alt="Close Window" /></a>
  <form method="post" class="signin" action="https://#">
    <fieldset class="textbox">
      <div id="register_error" class="error"></div>
      <label class="username">
        <span>Username:</span>
        <input type="text" id="user" placeholder="Username" />
      </label>

      <label class="password">
        <span>Password</span>
        <input id="pass" type="password" placeholder="Password" />
      </label>

      <label class="password">
        <span>Confirm Password</span>
        <input id="rpass" type="password" placeholder="Confirm Password" />
      </label>

      <label class="email">
        <span>Email:</span>
        <input type="text" id="email" placeholder="Email">
      </label>

      <p>
        <input type="submit" id="register-submit-button" value="Register &rarr;"/>
      </p>
    </fieldset>
  </form>
</div>
<img class="leftlogo" src="_static/OpenDSALogoT64.png" alt="Logo"/><div class="title-wrapper">
          <div class="title-inbetween" style="display: table-cell; vertical-align: middle;">
            <div class="title-content">
              <h1 class="heading" ><a href="index.html">
                <span>Data Structures and Algorithms</span></a></h1>
              <h2 class="heading" ><span>Chapter 6 General Trees and Union-Find (optional)</span></h2>
            </div>
          </div>
        </div>
      </div>
      <div class="topnav">
        <p>
            <a style="float:left;color:blue;" href="../source/UnionFind.rst.rst"
              target="_blank" rel="nofollow">Show Source | </a>&#160;&#160;
            <a class="abt" style="float:left;color:blue;" href="#" rel="nofollow">| About</a>&#160;&#160;

          
        «&#160;&#160;<a id="prevmod" href="GenTreeIntro.html">6.<span class="section-number">1. </span>General Trees (optional)</a>
        &#160;&#160;::&#160;&#160;
        <a  class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a  id="nextmod" href="SequentialRep.html">6.<span class="section-number">3. </span>Sequential Tree Representations (optional)</a>&#160;&#160;»


        </p>
      </div>
       
      <div class="content">
        
  <script>ODSA.SETTINGS.MODULE_SECTIONS = ['the-unionfind-problem', 'parent-pointer-trees', 'equivalence-classes', 'weighted-union', 'path-compression'];</script><script>ODSA.SETTINGS.DISP_MOD_COMP = true;ODSA.SETTINGS.MODULE_NAME = "UnionFind";ODSA.SETTINGS.MODULE_LONG_NAME = "The Union/Find Algorithm (optional)";ODSA.SETTINGS.MODULE_CHAPTER = "General Trees and Union-Find (optional)"; ODSA.SETTINGS.BUILD_DATE = "2021-11-06 20:22:01"; ODSA.SETTINGS.BUILD_CMAP = true;JSAV_OPTIONS['lang']='en';JSAV_EXERCISE_OPTIONS['code']='pseudo';</script><link href="../../../AV/General/UFCON.css" rel="stylesheet" type="text/css" />
<div class="section" id="the-union-find-algorithm-optional">
<h1>6.<span class="section-number">2. </span>The Union/Find Algorithm (optional)<a class="headerlink" href="#the-union-find-algorithm-optional" title="Permalink to this headline">¶</a></h1>
<div class="section" id="the-union-find-problem">
<h2>6.<span class="section-number">2.1. </span>The Union/Find Problem<a class="headerlink" href="#the-union-find-problem" title="Permalink to this headline">¶</a></h2>
<p><a class="reference internal" href="Glossary.html#term-general-tree"><span class="xref std std-term">General trees</span></a> are trees whose
<a class="reference internal" href="Glossary.html#term-internal-node"><span class="xref std std-term">internal nodes</span></a> have no fixed number of
<a class="reference internal" href="Glossary.html#term-child"><span class="xref std std-term">children</span></a>.
Compared to general trees, <a class="reference internal" href="Glossary.html#term-binary-tree"><span class="xref std std-term">binary trees</span></a> are
relatively easy to implement because each internal node of a binary
tree can just store two pointers to reach its (potential) children.
In a general tree, we have to deal with the fact that a given node
might have no children or few children or many children.</p>
<p>Even in a general tree, each node can have only one <a class="reference internal" href="Glossary.html#term-parent"><span class="xref std std-term">parent</span></a>.
If we didn’t need to go from a node to its children, but instead only
needed to go from a node to its parent, then implementing a node would
be easy.
A simple way to represent such a general tree would be to store for
each node only a pointer to that node’s parent.
We will call this the <a class="reference internal" href="Glossary.html#term-parent-pointer-representation"><span class="xref std std-term">parent pointer representation</span></a> for
general trees.
Clearly this implementation is not general purpose, because it is
inadequate for such important operations as finding
the leftmost child or the right sibling for a node.
Thus, it may seem to be a poor idea to implement a general
tree in this way.
However, the parent pointer implementation stores precisely the
information required to answer the following, useful question:
<strong>Given two nodes, are they in the same tree?</strong>
To answer this question, we need only follow the series of parent
pointers from each node to its respective root.
If both nodes reach the same root, then they must be in the same tree.
If the roots are different, then the two nodes are not in the same
tree.
The process of finding the ultimate root for a given node we will call
<a class="reference internal" href="Glossary.html#term-find"><span class="xref std std-term">FIND</span></a>.</p>
<div class="section" id="parent-pointer-trees">
<h3>6.<span class="section-number">2.1.1. </span>Parent Pointer Trees<a class="headerlink" href="#parent-pointer-trees" title="Permalink to this headline">¶</a></h3>
<p>The parent pointer representation is most often used to maintain a
collection of <a class="reference internal" href="Glossary.html#term-disjoint-sets"><span class="xref std std-term">disjoint sets</span></a>.
Two disjoint sets share no members in common (their intersection is
empty).
A collection of disjoint sets partitions some objects
such that every object is in exactly one of the disjoint sets.
There are two basic operations that we wish to support:</p>
<ol class="arabic simple">
<li><p>Determine if two objects are in the same set (the FIND operation), and</p></li>
<li><p>Merge two sets together.</p></li>
</ol>
<p>Because two merged sets are united, the merging operation is
called <a class="reference internal" href="Glossary.html#term-union"><span class="xref std std-term">UNION</span></a> and the whole process of determining if two
objects are in the same set and then merging the sets goes by the name
<a class="reference internal" href="Glossary.html#term-union-find"><span class="xref std std-term">UNION/FIND</span></a>.</p>
<p>To implement UNION/FIND, we represent each disjoint set with a
separate general tree.
Two objects are in the same disjoint set if they are in the same tree.
Every node of the tree (except for the root) has precisely one parent.
Thus, each node requires the same space to represent it.
The collection of objects is typically stored in an array, where each
element of the array corresponds to one object, and each element
stores the object’s value (or a pointer to the object).
The objects also correspond to nodes in the various disjoint trees
(one tree for each disjoint set), so we also store the parent value
with each object in the array.
Those nodes that are the roots of their respective trees store an
appropriate indicator.
Note that this representation means that a single array is being used
to implement a collection of trees.
This makes it easy to merge trees together with UNION operations.</p>
<p>Here is an implementation for parent pointer trees and the UNION/FIND
process.</p>
<div id="ParPtrTree1_UF1_-UF2_code"><ul><li><a href="#ParPtrTree1_UF1_-UF2_code_Java_Generic">Java</a></li><li><a href="#ParPtrTree1_UF1_-UF2_code_Python">Python</a></li></ul><div id="ParPtrTree1_UF1_-UF2_code_Java_Generic"><div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="c1">// General Tree implementation for UNION/FIND</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ParPtrTree</span> <span class="p">{</span>
  <span class="kd">private</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">array</span><span class="p">;</span>     <span class="c1">// Node array</span>

  <span class="n">ParPtrTree</span><span class="p">(</span><span class="kt">int</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">array</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">size</span><span class="o">]</span><span class="p">;</span> <span class="c1">// Create node array</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">array</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>       <span class="c1">// Each node is its own root to start</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// Merge two subtrees if they are different</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">UNION</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">root1</span> <span class="o">=</span> <span class="n">FIND</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>     <span class="c1">// Find root of node a</span>
    <span class="kt">int</span> <span class="n">root2</span> <span class="o">=</span> <span class="n">FIND</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>     <span class="c1">// Find root of node b</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">root1</span> <span class="o">!=</span> <span class="n">root2</span><span class="p">)</span> <span class="p">{</span>          <span class="c1">// Merge two trees</span>
      <span class="n">array</span><span class="o">[</span><span class="n">root1</span><span class="o">]</span> <span class="o">=</span> <span class="n">root2</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// Return the root of curr&#39;s tree</span>
  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">FIND</span><span class="p">(</span><span class="kt">int</span> <span class="n">curr</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">array</span><span class="o">[</span><span class="n">curr</span><span class="o">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">curr</span> <span class="o">=</span> <span class="n">array</span><span class="o">[</span><span class="n">curr</span><span class="o">]</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">curr</span><span class="p">;</span> <span class="c1">// Now at root</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div><div id="ParPtrTree1_UF1_-UF2_code_Python"><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># General Tree implementation for UNION/FIND</span>
<span class="k">class</span> <span class="nc">ParPtrTree</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1"># Each node is its own root to start</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">array</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">size</span>

    <span class="c1"># Merge two subtrees if they are different</span>
    <span class="k">def</span> <span class="nf">UNION</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="n">root1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">FIND</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>  <span class="c1"># Find root of node a</span>
        <span class="n">root2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">FIND</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>  <span class="c1"># Find root of node b</span>
        <span class="k">if</span> <span class="n">root1</span> <span class="o">!=</span> <span class="n">root2</span><span class="p">:</span>    <span class="c1"># Merge two trees</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="n">root1</span><span class="p">]</span> <span class="o">=</span> <span class="n">root2</span>

    <span class="c1"># Return the root of curr&#39;s tree</span>
    <span class="k">def</span> <span class="nf">FIND</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">curr</span><span class="p">):</span>
        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="n">curr</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">curr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="n">curr</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">curr</span>  <span class="c1"># Now at root</span>
</pre></div>
</div>
</div></div><script>$(function() {$( "#ParPtrTree1_UF1_-UF2_code" ).tabs();});</script><p>The <code class="docutils literal notranslate"><span class="pre">ParPtrTree</span></code> class has an array where each array position
corresponds to one object in some collection.
Each array element stores the array index for its parent.
There are two main methods to implement.
Method <code class="docutils literal notranslate"><span class="pre">UNION</span></code> merges two sets together, where each set corresponds
to a tree.
Method <code class="docutils literal notranslate"><span class="pre">FIND</span></code> is used to find the ultimate root for a node.</p>
<p>An application using the UNION/FIND operations
should store a set of <span class="math notranslate nohighlight">\(n\)</span> objects, where each object is assigned
a unique index in the range 0 to <span class="math notranslate nohighlight">\(n-1\)</span>.
The indices refer to the corresponding parent pointers in the array.
Class <code class="docutils literal notranslate"><span class="pre">ParPtrTree</span></code> creates and initializes the
UNION/FIND array, and methods <code class="docutils literal notranslate"><span class="pre">UNION</span></code> and
<code class="docutils literal notranslate"><span class="pre">FIND</span></code> take array indices as inputs.</p>
<div class="divdgm" id="uffig">
<div id="UFfigCON">
</div>
<p class="caption"><span class="caption-text"> Figure 6.3.1: The parent pointer array implementation.
Each node corresponds to a position in the node array,
which stores its value and a pointer to its parent.
The parent pointers are represented by an array index corresponding
to the position of the parent.
The root of any tree stores a special value, such as -1.
This is represented graphically in the figure by a
slash in the “Parent’s Index” box.
This figure shows two trees stored in the same parent pointer array,
one rooted at <span class="math notranslate nohighlight">\(F\)</span> (with a total of 9 nodes),
and the other rooted at <span class="math notranslate nohighlight">\(J\)</span> (with a total of 1 node).</span></p>
</div>
</div>
<div class="section" id="equivalence-classes">
<h3>6.<span class="section-number">2.1.2. </span>Equivalence Classes<a class="headerlink" href="#equivalence-classes" title="Permalink to this headline">¶</a></h3>
<p>Consider the problem of assigning the members of a set to
disjoint subsets called
<a class="reference internal" href="Glossary.html#term-equivalence-class"><span class="xref std std-term">equivalence classes</span></a>.
Recall that an
<a class="reference internal" href="Glossary.html#term-equivalence-relation"><span class="xref std std-term">equivalence relation</span></a> is
<a class="reference internal" href="Glossary.html#term-reflexive"><span class="xref std std-term">reflexive</span></a>, <a class="reference internal" href="Glossary.html#term-symmetric"><span class="xref std std-term">symmetric</span></a>, and <a class="reference internal" href="Glossary.html#term-transitive"><span class="xref std std-term">transitive</span></a>.
Thus, if objects <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(B\)</span> are equivalent, and objects
<span class="math notranslate nohighlight">\(B\)</span> and <span class="math notranslate nohighlight">\(C\)</span> are equivalent, then we must be able to recognize
that objects <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(C\)</span> are also equivalent.
In this representation, since <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(B\)</span> are equivalent,
they must be in the same tree.
Likewise for <span class="math notranslate nohighlight">\(B\)</span> and <span class="math notranslate nohighlight">\(C\)</span>.
We can recognize that <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(C\)</span> are equivalent because
they must also be in the same tree.</p>
<p>There are many practical uses for disjoint sets and representing
equivalences.
For example, consider this graph of ten nodes labeled <span class="math notranslate nohighlight">\(A\)</span> through
<span class="math notranslate nohighlight">\(J\)</span>.</p>
<div class="divdgm" id="ufconcom">
<div id="UFconcomCON">
</div>
<p class="caption"><span class="caption-text"> Figure 6.3.2: A graph with two connected components.
The tree of Figure <a href="UnionFind.html#uffig">6.3.1</a> shows the corresponding
tree structure resulting form processing the edges to determine the
connected components.</span></p>
</div>
<p>Notice that for nodes <span class="math notranslate nohighlight">\(A\)</span> through <span class="math notranslate nohighlight">\(I\)</span>, there is some
series of edges that connects any pair of these nodes, but node
<span class="math notranslate nohighlight">\(J\)</span> is disconnected from the rest of the nodes.
Such a graph might be used to represent connections such as wires
between components on a circuit board, or roads between cities.
We can consider two nodes of the graph to be equivalent if there is a
path between them.
Thus, nodes <span class="math notranslate nohighlight">\(A\)</span>, <span class="math notranslate nohighlight">\(H\)</span>, and <span class="math notranslate nohighlight">\(E\)</span> would
be considered as equivalent, but <span class="math notranslate nohighlight">\(J\)</span> is not
equivalent to any other.
A subset of equivalent (connected) edges in a graph is called a
<a class="reference internal" href="Glossary.html#term-connected-component"><span class="xref std std-term">connected component</span></a>.
The goal is to quickly classify the objects
into disjoint sets that correspond to the connected components.</p>
<p>Another use for UNION/FIND occurs in <a class="reference internal" href="Glossary.html#term-kruskal-s-algorithm"><span class="xref std std-term">Kruskal’s algorithm</span></a> for
computing the
<a class="reference internal" href="MCST.html#mcst"><span class="std std-ref">minimal-cost spanning tree</span></a>
for a <a class="reference internal" href="Glossary.html#term-graph"><span class="xref std std-term">graph</span></a>.
That algorithm seeks to select the cheapest subset of the edges that
still connects all of the nodes in the graph.
It does so by processing all edges of the graph from shortest to
longest, only adding an edge to the connecting subset if it does not
connect two nodes that already have some series of edges connecting
them.</p>
<p>The input to the UNION/FIND algorithm is typically  a series of
equivalence pairs.
In the case of the connected components example, the equivalence pairs
would simply be the set of edges in the graph.
An equivalence pair might say that object <span class="math notranslate nohighlight">\(C\)</span> is equivalent to
object <span class="math notranslate nohighlight">\(A\)</span>.
If so, <span class="math notranslate nohighlight">\(C\)</span> and <span class="math notranslate nohighlight">\(A\)</span> are placed in the same subset.
If a later equivalence relates <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(B\)</span>, then
by implication <span class="math notranslate nohighlight">\(C\)</span> is also equivalent to <span class="math notranslate nohighlight">\(B\)</span>.
Thus, an equivalence pair may cause two subsets to merge, each of
which contains several objects.</p>
<p>Equivalence classes can be managed efficiently with the UNION/FIND
algorithm.
Initially, each object is at the root of its own tree.
An equivalence pair is processed by checking to see if both objects
of the pair are in the same tree by calling  <code class="docutils literal notranslate"><span class="pre">FIND</span></code> on each of them.
If their roots are the same, then no change need be made because the
objects are already in the same equivalence class.
Otherwise, the two equivalence classes should be merged by the
<code class="docutils literal notranslate"><span class="pre">UNION</span></code> method.</p>
<p>The parent pointer representation places no limit on the number of
nodes that can share a parent.
To make equivalence processing as efficient as possible,
the distance from each node to the root of its respective tree should
be as small as possible.
Thus, we would like to keep the height of the trees small when merging
two equivalence classes together.
Ideally, each tree would have all nodes pointing directly to the root.
Achieving this goal all the time would require too much additional
processing to be worth the effort, so we must settle for getting as
close as possible.</p>
</div>
<div class="section" id="weighted-union">
<h3>6.<span class="section-number">2.1.3. </span>Weighted Union<a class="headerlink" href="#weighted-union" title="Permalink to this headline">¶</a></h3>
<p>A low-cost approach to reducing the height is to be smart about how
two trees are joined together.
One simple technique, called the
<a class="reference internal" href="Glossary.html#term-weighted-union-rule"><span class="xref std std-term">weighted union rule</span></a>,
joins the tree with fewer nodes to the tree with more nodes by making
the smaller tree’s root point to the root of the bigger tree.
This will limit the total depth of the tree to <span class="math notranslate nohighlight">\(O(\log n)\)</span>,
because the depth of nodes only in the smaller tree will now increase
by one, and the depth of the deepest node in the combined tree can
only be at most one deeper than the deepest node before the trees were
combined.
The total number of nodes in the combined tree is therefore at least
twice the number in the smaller subtree.
Thus, the depth of any node can be increased at most <span class="math notranslate nohighlight">\(\log n\)</span>
times when <span class="math notranslate nohighlight">\(n\)</span> equivalences are processed
(since each addition to the depth must be accompanied by at least
doubling the size of the tree).</p>
<p>Here is an implementation for the UNION method when using weighted
union.</p>
<div id="ParPtrTree2_UnionFind_code"><ul><li><a href="#ParPtrTree2_UnionFind_code_Java_Generic">Java</a></li><li><a href="#ParPtrTree2_UnionFind_code_Python">Python</a></li></ul><div id="ParPtrTree2_UnionFind_code_Java_Generic"><div class="highlight-java notranslate"><div class="highlight"><pre><span></span>  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">UNION</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">root1</span> <span class="o">=</span> <span class="n">FIND</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>     <span class="c1">// Find root of node a</span>
    <span class="kt">int</span> <span class="n">root2</span> <span class="o">=</span> <span class="n">FIND</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>     <span class="c1">// Find root of node b</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">root1</span> <span class="o">!=</span> <span class="n">root2</span><span class="p">)</span> <span class="p">{</span>          <span class="c1">// Merge with weighted union</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">weights</span><span class="o">[</span><span class="n">root2</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">weights</span><span class="o">[</span><span class="n">root1</span><span class="o">]</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">array</span><span class="o">[</span><span class="n">root1</span><span class="o">]</span> <span class="o">=</span> <span class="n">root2</span><span class="p">;</span>
        <span class="n">weights</span><span class="o">[</span><span class="n">root2</span><span class="o">]</span> <span class="o">+=</span> <span class="n">weights</span><span class="o">[</span><span class="n">root1</span><span class="o">]</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">array</span><span class="o">[</span><span class="n">root2</span><span class="o">]</span> <span class="o">=</span> <span class="n">root1</span><span class="p">;</span>
        <span class="n">weights</span><span class="o">[</span><span class="n">root1</span><span class="o">]</span> <span class="o">+=</span> <span class="n">weights</span><span class="o">[</span><span class="n">root2</span><span class="o">]</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
</pre></div>
</div>
</div><div id="ParPtrTree2_UnionFind_code_Python"><div class="highlight-python notranslate"><div class="highlight"><pre><span></span>    <span class="k">def</span> <span class="nf">UNION</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="n">root1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">FIND</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>   <span class="c1"># Find root of node a</span>
        <span class="n">root2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">FIND</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>   <span class="c1"># Find root of node b</span>
        <span class="k">if</span> <span class="n">root1</span> <span class="o">!=</span> <span class="n">root2</span><span class="p">:</span>     <span class="c1"># Merge with weighted union</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">root2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">root1</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="n">root1</span><span class="p">]</span> <span class="o">=</span> <span class="n">root2</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">root2</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">root1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="n">root2</span><span class="p">]</span> <span class="o">=</span> <span class="n">root1</span><span class="p">;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">root1</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">root2</span><span class="p">];</span>
</pre></div>
</div>
</div></div><script>$(function() {$( "#ParPtrTree2_UnionFind_code" ).tabs();});</script><p>The following slideshow illustrates a series of UNION operations with
weighted union.</p>
<div id="ufCON" class="ssAV" data-points="0.0" data-threshold="1.0" data-type="ss" data-required="False" data-short-name="ufCON" data-long-name="Union/Find Example" data-exer-id="" alt="Union/Find Example" tabIndex="-1">
 <span class="jsavcounter"></span>
 <a class="jsavsettings" href="#">Settings</a>
 <div class="jsavcontrols"></div>
 <p class="jsavoutput jsavline"></p>
 <div class="jsavcanvas"></div>
 <div class="prof_indicators">
  <img id="ufCON_check_mark" class="prof_check_mark" src="_static/Images/green_check.png" alt="Proficient" />
  <span id="ufCON_cm_saving_msg" class="cm_saving_msg">Saving...</span>
  <span id="ufCON_cm_error_msg" class="cm_error_msg">
   <img id="ufCON_cm_warning_icon" class="cm_warning_icon" src="_static/Images/warning.png" alt="Error Saving" /><br />
   Server Error<br />
   <a href="#" class="resubmit_link">Resubmit</a>
  </span>
 </div>
</div>
<p></p>
</div>
<div class="section" id="path-compression">
<h3>6.<span class="section-number">2.1.4. </span>Path Compression<a class="headerlink" href="#path-compression" title="Permalink to this headline">¶</a></h3>
<p>The weighted union rule helps to minimize the depth of the tree, but
we can do better than this.
<a class="reference internal" href="Glossary.html#term-path-compression"><span class="xref std std-term">Path compression</span></a> is a method that tends to
create extremely shallow trees.
Path compression takes place while finding the root
for a given node <span class="math notranslate nohighlight">\(X\)</span>.
Call this root <span class="math notranslate nohighlight">\(R\)</span>.
Path compression resets the parent of every node on the path from
<span class="math notranslate nohighlight">\(X\)</span> to <span class="math notranslate nohighlight">\(R\)</span> to point directly to <span class="math notranslate nohighlight">\(R\)</span>.
This can be implemented by first finding <span class="math notranslate nohighlight">\(R\)</span>.
A second pass is then made along the path from <span class="math notranslate nohighlight">\(X\)</span> to <span class="math notranslate nohighlight">\(R\)</span>,
assigning the parent field of each node encountered to <span class="math notranslate nohighlight">\(R\)</span>.
Alternatively, a recursive algorithm can be implemented as follows.
This version of <code class="docutils literal notranslate"><span class="pre">FIND</span></code> not only returns the root of the
current node, but also makes all ancestors of the current node point
to the root.</p>
<div id="ParPtrTree2_PathCompress_code"><ul><li><a href="#ParPtrTree2_PathCompress_code_Java_Generic">Java</a></li><li><a href="#ParPtrTree2_PathCompress_code_Python">Python</a></li></ul><div id="ParPtrTree2_PathCompress_code_Java_Generic"><div class="highlight-java notranslate"><div class="highlight"><pre><span></span>  <span class="c1">// Return the root of curr&#39;s tree with path compression</span>
  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">FIND</span><span class="p">(</span><span class="kt">int</span> <span class="n">curr</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">array</span><span class="o">[</span><span class="n">curr</span><span class="o">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="n">curr</span><span class="p">;</span> <span class="c1">// At root</span>
    <span class="n">array</span><span class="o">[</span><span class="n">curr</span><span class="o">]</span> <span class="o">=</span> <span class="n">FIND</span><span class="p">(</span><span class="n">array</span><span class="o">[</span><span class="n">curr</span><span class="o">]</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">array</span><span class="o">[</span><span class="n">curr</span><span class="o">]</span><span class="p">;</span>
  <span class="p">}</span>
</pre></div>
</div>
</div><div id="ParPtrTree2_PathCompress_code_Python"><div class="highlight-python notranslate"><div class="highlight"><pre><span></span>    <span class="c1"># Return the root of curr&#39;s tree with path compression</span>
    <span class="k">def</span> <span class="nf">FIND</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">curr</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="n">curr</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">curr</span>  <span class="c1"># At root</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="n">curr</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">FIND</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="n">curr</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="n">curr</span><span class="p">];</span>
</pre></div>
</div>
</div></div><script>$(function() {$( "#ParPtrTree2_PathCompress_code" ).tabs();});</script><p>The following slide show illustrates path compression using the last
step in the previous example.</p>
<div id="pathcompCON" class="ssAV" data-points="0.0" data-threshold="1.0" data-type="ss" data-required="False" data-short-name="pathcompCON" data-long-name="Union/Find Path Compression Example" data-exer-id="" alt="Union/Find Path Compression Example" tabIndex="-1">
 <span class="jsavcounter"></span>
 <a class="jsavsettings" href="#">Settings</a>
 <div class="jsavcontrols"></div>
 <p class="jsavoutput jsavline"></p>
 <div class="jsavcanvas"></div>
 <div class="prof_indicators">
  <img id="pathcompCON_check_mark" class="prof_check_mark" src="_static/Images/green_check.png" alt="Proficient" />
  <span id="pathcompCON_cm_saving_msg" class="cm_saving_msg">Saving...</span>
  <span id="pathcompCON_cm_error_msg" class="cm_error_msg">
   <img id="pathcompCON_cm_warning_icon" class="cm_warning_icon" src="_static/Images/warning.png" alt="Error Saving" /><br />
   Server Error<br />
   <a href="#" class="resubmit_link">Resubmit</a>
  </span>
 </div>
</div>
<p></p>
<p>Path compression keeps the cost of each FIND operation very
close to constant.</p>
<p>To be more precise about what is meant by “very close to constant”,
the cost of path compression for <span class="math notranslate nohighlight">\(n\)</span> FIND operations on
<span class="math notranslate nohighlight">\(n\)</span> nodes (when combined with the weighted union rule for
joining sets) is approximately
<span class="math notranslate nohighlight">\(\Theta(n \log^* n)\)</span>.
The notation <span class="math notranslate nohighlight">\(\log^* n\)</span> means the number of times that
the log of <span class="math notranslate nohighlight">\(n\)</span> must be taken before <span class="math notranslate nohighlight">\(n \leq 1\)</span>.
For example, <span class="math notranslate nohighlight">\(\log^* 65536\)</span> is 4 because
<span class="math notranslate nohighlight">\(\log 65536 = 16, \log 16 = 4, \log 4 = 2\)</span>, and finally
<span class="math notranslate nohighlight">\(\log 2 = 1\)</span>.
Thus, <span class="math notranslate nohighlight">\(\log^* n\)</span> grows <em>very</em> slowly, so the cost for a series
of <span class="math notranslate nohighlight">\(n\)</span> FIND operations is very close to <span class="math notranslate nohighlight">\(n\)</span>.</p>
<p>Note that this does not mean that the tree resulting from
processing <span class="math notranslate nohighlight">\(n\)</span> equivalence pairs necessarily has depth
<span class="math notranslate nohighlight">\(\Theta(\log^* n)\)</span>.
One can devise a series of equivalence operations that yields
<span class="math notranslate nohighlight">\(\Theta(\log n)\)</span> depth for the resulting tree.
However, many of the equivalences in such a series will look only at
the roots of the trees being merged, requiring little processing time.
The <em>total</em> amount of processing time required for <span class="math notranslate nohighlight">\(n\)</span>
operations will be <span class="math notranslate nohighlight">\(\Theta(n \log^* n)\)</span>,
yielding nearly constant time for each equivalence operation.
This is an example of
<a class="reference internal" href="AmortAnal.html#amortanal"><span class="std std-ref">amortized analysis</span></a>.</p>
<p>The expression <span class="math notranslate nohighlight">\(\log^* n\)</span> is closely related to the inverse of
Ackermann’s function.
For more information about Ackermann’s function and the cost of path
compression for UNION/FIND, see <span id="id1">[Tarjan75]</span>.
The survey article by Galil &amp; Italiano <span id="id2">[GalilItaliano91]</span>
covers many aspects of the equivalence class problem.</p>
<div
    id="UnionFindPRO"
    class="embedContainer"
    data-exer-name="UnionFindPRO"
    data-long-name="Union/Find Proficiency Exercise"
    data-short-name="UnionFindPRO"
    data-frame-src="../../../AV/General/UnionFindPRO.html?localMode=true&amp;module=UnionFind&amp;selfLoggingEnabled=false&amp;JXOP-debug=true&amp;JOP-lang=en&amp;JXOP-code=pseudo"
    data-frame-width="950"
    data-frame-height="650"
    data-vertical-scrolling="no"
    data-external="false"
    data-points="1.0"
    data-required="True"
    data-showhide="show"
    data-threshold="0.9"
    data-type="pe"
    data-exer-id="">
  
  <div class="center">
    <div id="UnionFindPRO_iframe"></div>
  </div>
</div>
<script type="text/javascript" src="../../../AV/General/UFfigCON.js"></script>
<script type="text/javascript" src="../../../AV/General/UFconcomCON.js"></script>
<script type="text/javascript" src="../../../AV/General/ufCON.js"></script>
<script type="text/javascript" src="../../../AV/General/pathcompCON.js"></script>
</div>
</div>
</div>


      </div>
      <div class="bottomnav">
      <p><span class="email_div" style="display:inline;"><a id="contact_us" class="contact" style="float:left;color:blue;" rel="nofollow" href="mailto:">Contact Us |</a><a style="float:left;color:blue;" rel="nofollow" href="../../../lib/Privacy.html" target="_blank">| Privacy |</a> <a style="float:left;color:blue;" rel="nofollow" href="../../../lib/license.html" target="_blank">| License</a></span>&#160;&#160;
      
        «&#160;&#160;<a id="prevmod1" href="GenTreeIntro.html">6.<span class="section-number">1. </span>General Trees (optional)</a>
        &#160;&#160;::&#160;&#160;
        <a  class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a  id="nextmod1" href="SequentialRep.html">6.<span class="section-number">3. </span>Sequential Tree Representations (optional)</a>&#160;&#160;»

</p>
      </div>
      <img style="float:right;" src="_static/nsf1.gif" height="62" width="62" alt="nsf"/>


    <div class="footer">
      <p>
        <span class="email_div" style="display:inline;">
          <a id="contact_us" class="contact" style="float:left;color:blue;" rel="nofollow" href="mailto:">Contact Us |</a>
          <a id="bugreport-link" style="float:left;color:blue;" class="bugreport-link" href="#">| Report a bug</a>
        </span>
      </p>
        &copy; Copyright 2016 by OpenDSA Project Contributors and distributed under an MIT license.
      Last updated on Nov 06, 2021.
      Created using <a target="_blank" href="http://sphinx.pocoo.org/">Sphinx</a> 2.4.4.
    </div>
    
<div id="bugreport-box" class="bugreport-popup ">
  <a href="#" class="close"><img src="_static/Images/close_pop.png" class="btn_close" title="Close Window" alt="Close Window" /></a>
  <form method="post" class="report" action="https://#">
    <fieldset class="textbox">
      <div id="bug_error" class="error"></div>
      <label>
        <span>Summary*:</span>
        <input type="text" id="b_title" placeholder="Summary" />
      </label>

      <label class="os">
        <span>Operating system*:</span>
        <select id="b_os">
          <option value="windows">Windows</option>
          <option value="macos">Mac OS</option>
          <option value="linux">Linux</option>
          <option value="ios">iOS</option>
          <option value="android">Android</option>
          <option value="other">Other</option>
        </select>
      </label>

      <label class="browser">
        <span>Browser*:</span>
        <select id="b_browser">
          <option value="chrome">Chrome</option>
          <option value="safari">Safari</option>
          <option value="internetexplorer">Internet Explorer</option>
          <option value="opera">Opera</option>
          <option value="other">Other</option>
        </select>
      </label>

      <label class="description">
        <span>Description*:</span><br>
        <textarea id="b_description" rows="5" cols="25" placeholder="***BUG** Please enter: (1) a consice description of the problem. (2) steps to reproduce bug. (3) the version of your browser and operating system."></textarea>
      </label>

      <label class="screenshot">
        <span>Attach a screenshot (optional):</span>
        <input type="file" id="b_screenshot" accept="image/*" placeholder="Attach a screenshot (optional)">
      </label>

      <p>
        <input type="submit" id="bug-submit-button" value="Submit &rarr;"/>
      </p>
    </fieldset>
  </form>
</div>

  </body>
</html>