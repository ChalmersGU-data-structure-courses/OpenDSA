{"concepts": {"2-3 tree": "", "binary search tree property": "", "B-tree": "", "abstract data type": "", "ADT": "", "interface": "", "activation record": "", "local variable": "", "acyclic graph": "", "directed acyclic graph": "", "cycles <cycle>": "", "aggregate type": "", "composite type": "", "member": "", "algorithm": "", "problem": "", "program": "", "algorithm analysis": "", "growth rate": "", "upper bound": "", "lower bound": "", "asymptotic analysis": "", "asymptotic algorithm analysis": "", "all-pairs shortest paths problem": "", "Floyd's algorithm": "", "amortized analysis": "", "amortized complexity": "", "complexity": "", "amortized cost": "", "array-based list": "", "array": "", "array-based stack": "", "stack": "", "array-based queue": "", "queue": "", "assembly code": "", "intermediate code": "", "AVL Tree": "", "double rotation": "", "single rotation": "", "balanced tree": "", "B$^+$-tree": "", "B$^*$-tree": "", "bad reference": "", "NullPointerException": "", "bag": "", "multilist": "", "binary search tree": "", "AVL tree": "", "BST": "", "splay tree": "", "binary tree": "", "binary trie": "", "complete binary tree": "", "bintree": "", "flyweight": "", "breadth-first search": "", "BFS": "", "bubble sort": "", "bucket hashing": "", "bucket": "", "buffer": "", "dirty bit": "", "buffer pool": "", "flush": "", "caching": "", "buffering": "", "class": "", "member function": "", "data member": "", "closed hash system": "", "open addressing": "", "code optimization": "", "collision resolution policy": "", "collision resolution": "", "compiler": "", "lexical analysis": "", "syntax analysis": "", "intermediate code generation": "", "code generation": "", "compile-time polymorphism": "", "Overloading": "", "cycle": "", "path": "", "simple cycle": "", "data item": "", "data field": "", "attribute": "", "instance variable": "", "data structure": "", "serialization": "", "data type": "", "simple type": "", "list": "", "depth-first search": "", "DFS": "", "depth-first search tree": "", "design pattern": "", "Composite design pattern": "", "strategy": "", "visitor": "", "DAG": "", "directed graph": "", "digraph": "", "disk drive": "", "peripheral storage": "", "disk I/O": "", "block": "", "sector": "", "dynamic allocation": "", "node": "", "dynamic programming": "", "Finite Automata": "", "state machine": "", "states": "", "accepting states <accepting states>": "", "Deterministic Finite Automata": "", "k-path": "", "graph": "", "edges <edge>": "", "vertices <vertex>": "", "adjacency matrix": "", "adjacency list": "", "traversal": "", "topological sort": "", "shortest paths": "", "dense graph": "", "sparse graph": "", "labeled graph": "", "undirected graph": "", "weighted graph": "", "unweighted graph": "", "order of growth": "", "linear growth rate": "", "quadratic growth rate": "", "exponential growth rate": "", "hash system": "", "hash function": "", "open hash system": "", "hashing": "", "hash table": "", "heap": "", "priority queue": "", "max heap": "", "min heap": "", "heapsort": "", "replacement selection": "", "inherit": "", "base class": "", "subclass": "", "Parse tree": "", "kd tree": "", "discriminator": "", "key": "", "key space": "", "key sort": "", "key-space decomposition": "", "object-space decomposition": "", "image-space decomposition": "", "Kruskal's algorithm": "", "UNION/FIND": "", "interpreter": "", "linked list": "", "automatic variable": "", "stack variable": "", "locality of reference": "", "80/20 rule": "", "lower bounds proof": "", "adversary argument": "", "sorting lower bound": "", "search lower bound": "", "element": "", "memory hierarchy": "", "primary storage": "", "secondary storage": "", "memory manager": "", "buddy method": "", "minimal-cost spanning tree": "", "Prim's algorithm": "", "MCST": "", "MST": "", "tree": "", "modulus": "", "mod": "", "multi-dimensional search structure": "", "multi-dimensional search key": "", "neighbor": "", "adjacent": "", "depth": "", "NP-Complete": "", "NP": "", "NP-hard": "", "clique": "", "non-deterministic polynomial time algorithm": "", "non-deterministic choice": "", "object": "", "object-oriented programming paradigm": "", "cohesion": "", "encapsulation": "", "polymorphism": "", "abstraction": "", "parser": "", "parse tree": "", "vertex": "", "pointer": "", "variable": "", "address": "", "pointee": "", "shallow copy": "", "dereference": "", "initialization": "", "run-time polymorphism": "", "RAM": "", "main memory": "", "greedy algorithm": "", "Dijkstra's algorith": "", "proof": "", "NP-Completeness proof": "", "proof by contradiction": "", "proof by induction": "", "dequeue": "", "enqueue": "", "random access memory": "", "recursion": "", "recurrence relation": "", "recursive function": "", "base case": "", "recursive call": "", "binary search": "", "reference": "", "Overriding": "", "runtime stack": "", "scanner": "", "search tree": "", "Binary Search Tree": "", "search trie": "", "alphabet trie": "", "self-organizing list": "", "move-to-front": "", "transpose": "", "deserialization": "", "sequential tree representation": "", "boolean": "", "integer": "", "singly linked list": "", "one-way list": "", "spatial data structure": "", "PR quadtree": "", "Splay Tree": "", "splaying": "", "push": "", "pop": "", "subgraph": "", "tokens": "", "trie": "", "alphebet trie": "", "variable-length coding": "", "Huffman codes": "", "fixed-length coding": "", "vector": "", "sequence": "", "dynamic array": ""}, "linking_phrase": {"has": " has", "formof": " form of\n", "abbreviation": " abbreviation", "logicallydefines": " logically defines\n", "stores": " stores", "types": " types", "hasno": " has no\n", "synonym": " synonym", "solves": " solves", "implementedby": " implemented by\n", "keyconcept": " key concept", "formalsynonym": " formal synonym\n", "solvedby": " solved by", "is": " is", "usedin": " used in", "uses": " uses", "analogousto": " analogous to", "implementing": " implementing\n", "operations": " operations", "isa": " is a", "variant": " variant\n", "raises": " raises", "example": " example", "abbreviated": " abbreviated\n", "typeof": " type of", "composedof": " composed of", "operation": " operation\n", "caninclude": " can include", "changes": " changes", "performs": " performs", "phase": " phase", "knownas": " known as", "concept": " concept", "implements": " implements\n", "type": " type\n", "generates": " generates\n", "exampleof": " example of", "Read/write": " Read/write\n", "uniteofstorage": " unite of storage\n", "uniteofspace": " unite of space\n", "consistsof": " consists of\n", "contains": " contains", "problems": " problems\n", "conceptof": " concept of\n", "walksthrough": " walks through", "produces": " produces\n", "exampleuse": " example use", "storagetype": " storage type", "algorithms": " algorithms", "neverhave": " never have\n", "context": " context\n", "linkedto": " linked to", "createdby": " created by\n", "property": " property\n", "exampleproblem": " example problem\n", "instanceof": " instance of", "principle": " principle\n", "partof": " part of", "build": " build\n", "In": " In", "sequenceof": " sequence of\n", "value": " value\n", "pointto": " point to\n", "defaultcopy": " default copy\n", "getpointeevalue": " get pointee value\n", "requires": " requires\n", "form": " form", "identicalto": " identical to\n", "abbreviationfor": " abbreviation for", "expressedas": " expressed as", "implementedin": " implemented in\n", "includes": " includes", "similarto": " similar to", "ifnotinitialized": " if not initialized\n", "Knownas": " Known as", "responsiblefor": " responsible for\n", "heuristic": " heuristic", "reversedby": " reversed by", "accepts": " accepts\n", "contrastto": " contrast to\n"}, "connections": {"con-1": {"from": "2-3 tree", "to": "binary search tree property", "label": " has"}, "con-2": {"from": "2-3 tree", "to": "B-tree", "label": " form of\n"}, "con-3": {"from": "abstract data type", "to": "ADT", "label": " abbreviation"}, "con-4": {"from": "abstract data type", "to": "interface", "label": " logically defines\n"}, "con-5": {"from": "activation record", "to": "local variable", "label": " stores"}, "con-6": {"from": "acyclic graph", "to": "directed acyclic graph", "label": " types"}, "con-7": {"from": "acyclic graph", "to": "cycles <cycle>", "label": " has no\n"}, "con-8": {"from": "aggregate type", "to": "composite type", "label": " synonym"}, "con-9": {"from": "aggregate type", "to": "member", "label": " has\n"}, "con-10": {"from": "algorithm", "to": "problem", "label": " solves"}, "con-11": {"from": "algorithm", "to": "program", "label": " implemented by\n"}, "con-12": {"from": "algorithm analysis", "to": "growth rate", "label": " key concept"}, "con-13": {"from": "algorithm analysis", "to": "upper bound", "label": " key concept\n"}, "con-14": {"from": "algorithm analysis", "to": "lower bound", "label": " key concept\n"}, "con-15": {"from": "algorithm analysis", "to": "asymptotic analysis", "label": " synonym\n"}, "con-16": {"from": "algorithm analysis", "to": "asymptotic algorithm analysis", "label": " formal synonym\n"}, "con-17": {"from": "all-pairs shortest paths problem", "to": "Floyd's algorithm", "label": " solved by"}, "con-18": {"from": "amortized analysis", "to": "algorithm analysis", "label": " is"}, "con-19": {"from": "amortized complexity", "to": "amortized analysis", "label": " used in"}, "con-20": {"from": "amortized complexity", "to": "complexity", "label": " is\n"}, "con-21": {"from": "amortized cost", "to": "amortized complexity", "label": " used in"}, "con-22": {"from": "amortized cost", "to": "amortized analysis", "label": " used in\n"}, "con-23": {"from": "array-based list", "to": "array", "label": " uses"}, "con-24": {"from": "array-based stack", "to": "array-based list", "label": " analogous to"}, "con-25": {"from": "array-based stack", "to": "stack", "label": " implementing\n"}, "con-26": {"from": "array-based queue", "to": "array-based list", "label": " analogous to"}, "con-27": {"from": "array-based queue", "to": "queue", "label": " implementing\n"}, "con-28": {"from": "assembly code", "to": "intermediate code", "label": " form of"}, "con-29": {"from": "asymptotic analysis", "to": "algorithm analysis", "label": " synonym"}, "con-30": {"from": "asymptotic analysis", "to": "asymptotic algorithm analysis", "label": " formal synonym\n"}, "con-31": {"from": "AVL Tree", "to": "double rotation", "label": " operations"}, "con-32": {"from": "AVL Tree", "to": "single rotation", "label": " operations\n"}, "con-33": {"from": "B-tree", "to": "balanced tree", "label": " is a"}, "con-34": {"from": "B-tree", "to": "B$^+$-tree", "label": " variant\n"}, "con-35": {"from": "B-tree", "to": "B$^*$-tree", "label": " variant\n"}, "con-36": {"from": "bad reference", "to": "NullPointerException", "label": " raises"}, "con-37": {"from": "bag", "to": "multilist", "label": " synonym"}, "con-38": {"from": "binary search tree", "to": "AVL tree", "label": " example"}, "con-39": {"from": "binary search tree", "to": "binary search tree property", "label": " has\n"}, "con-40": {"from": "binary search tree", "to": "BST", "label": " abbreviated\n"}, "con-41": {"from": "binary search tree", "to": "splay tree", "label": " example\n"}, "con-42": {"from": "binary tree", "to": "binary search tree", "label": " example"}, "con-43": {"from": "binary tree", "to": "binary trie", "label": " example\n"}, "con-44": {"from": "binary tree", "to": "complete binary tree", "label": " example\n"}, "con-45": {"from": "binary tree", "to": "bintree", "label": " example\n"}, "con-46": {"from": "bintree", "to": "flyweight", "label": " uses"}, "con-47": {"from": "breadth-first search", "to": "BFS", "label": " abbreviation"}, "con-48": {"from": "bubble sort", "to": "algorithm", "label": " type of"}, "con-49": {"from": "bucket hashing", "to": "bucket", "label": " uses"}, "con-50": {"from": "buffer", "to": "dirty bit", "label": " uses"}, "con-51": {"from": "buffer pool", "to": "buffer", "label": " composed of"}, "con-52": {"from": "buffer pool", "to": "flush", "label": " operation\n"}, "con-53": {"from": "caching", "to": "buffering", "label": " synonym"}, "con-54": {"from": "class", "to": "member function", "label": " can include"}, "con-55": {"from": "class", "to": "data member", "label": " can include\n"}, "con-56": {"from": "closed hash system", "to": "open addressing", "label": " synonym"}, "con-57": {"from": "code optimization", "to": "assembly code", "label": " changes"}, "con-58": {"from": "collision resolution policy", "to": "collision resolution", "label": " performs"}, "con-59": {"from": "compiler", "to": "lexical analysis", "label": " phase"}, "con-60": {"from": "compiler", "to": "syntax analysis", "label": " phase\n"}, "con-61": {"from": "compiler", "to": "intermediate code generation", "label": " phase\n"}, "con-62": {"from": "compiler", "to": "code optimization", "label": " phase\n"}, "con-63": {"from": "compiler", "to": "code generation", "label": " phase\n"}, "con-64": {"from": "compile-time polymorphism", "to": "Overloading", "label": " known as"}, "con-65": {"from": "cycle", "to": "path", "label": " is"}, "con-66": {"from": "cycle", "to": "simple cycle", "label": " example\n"}, "con-67": {"from": "data item", "to": "data member", "label": " implemented by"}, "con-68": {"from": "data member", "to": "data field", "label": " synonym"}, "con-69": {"from": "data member", "to": "attribute", "label": " synonym\n"}, "con-70": {"from": "data member", "to": "instance variable", "label": " synonym\n"}, "con-71": {"from": "data structure", "to": "serialization", "label": " concept"}, "con-72": {"from": "data structure", "to": "abstract data type", "label": " implements\n"}, "con-73": {"from": "data type", "to": "abstract data type", "label": " implemented by"}, "con-74": {"from": "data type", "to": "aggregate type", "label": " type\n"}, "con-75": {"from": "data type", "to": "simple type", "label": " type\n"}, "con-76": {"from": "data type", "to": "list", "label": " example\n"}, "con-77": {"from": "data type", "to": "array", "label": " example\n"}, "con-78": {"from": "depth-first search", "to": "DFS", "label": " abbreviation"}, "con-79": {"from": "depth-first search", "to": "depth-first search tree", "label": " generates\n"}, "con-80": {"from": "design pattern", "to": "Composite design pattern", "label": " example"}, "con-81": {"from": "design pattern", "to": "flyweight", "label": " example\n"}, "con-82": {"from": "design pattern", "to": "strategy", "label": " example\n"}, "con-83": {"from": "design pattern", "to": "visitor", "label": " example\n"}, "con-84": {"from": "directed acyclic graph", "to": "DAG", "label": " abbreviation"}, "con-85": {"from": "directed graph", "to": "directed acyclic graph", "label": " types"}, "con-86": {"from": "directed graph", "to": "digraph", "label": " abbreviation\n"}, "con-87": {"from": "disk drive", "to": "peripheral storage", "label": " example of"}, "con-88": {"from": "disk drive", "to": "disk I/O", "label": " Read/write\n"}, "con-89": {"from": "disk drive", "to": "block", "label": " unite of storage\n"}, "con-90": {"from": "disk drive", "to": "sector", "label": " unite of space\n"}, "con-91": {"from": "dynamic allocation", "to": "node", "label": " example"}, "con-92": {"from": "dynamic programming", "to": "Floyd's algorithm", "label": " example"}, "con-93": {"from": "Finite Automata", "to": "state machine", "label": " synonym"}, "con-94": {"from": "Finite Automata", "to": "states", "label": " consists of\n"}, "con-95": {"from": "Finite Automata", "to": "accepting states <accepting states>", "label": " consists of\n"}, "con-96": {"from": "Finite Automata", "to": "Deterministic Finite Automata", "label": " example\n"}, "con-97": {"from": "Floyd's algorithm", "to": "k-path", "label": " uses"}, "con-98": {"from": "graph", "to": "edges <edge>", "label": " contains"}, "con-99": {"from": "graph", "to": "vertices <vertex>", "label": " contains\n"}, "con-100": {"from": "graph", "to": "adjacency matrix", "label": " implemented by\n"}, "con-101": {"from": "graph", "to": "adjacency list", "label": " implemented by\n"}, "con-102": {"from": "graph", "to": "traversal", "label": " problems\n"}, "con-103": {"from": "graph", "to": "topological sort", "label": " problems\n"}, "con-104": {"from": "graph", "to": "shortest paths", "label": " problems\n"}, "con-105": {"from": "graph", "to": "dense graph", "label": " types\n"}, "con-106": {"from": "graph", "to": "sparse graph", "label": " types\n"}, "con-107": {"from": "graph", "to": "directed graph", "label": " types\n"}, "con-108": {"from": "graph", "to": "acyclic graph", "label": " types\n"}, "con-109": {"from": "graph", "to": "labeled graph", "label": " types\n"}, "con-110": {"from": "graph", "to": "undirected graph", "label": " types\n"}, "con-111": {"from": "graph", "to": "weighted graph", "label": " types\n"}, "con-112": {"from": "graph", "to": "unweighted graph", "label": " types\n"}, "con-113": {"from": "growth rate", "to": "order of growth", "label": " synonym"}, "con-114": {"from": "growth rate", "to": "lower bound", "label": " type\n"}, "con-115": {"from": "growth rate", "to": "upper bound", "label": " type\n"}, "con-116": {"from": "growth rate", "to": "linear growth rate", "label": " example\n"}, "con-117": {"from": "growth rate", "to": "quadratic growth rate", "label": " example\n"}, "con-118": {"from": "growth rate", "to": "exponential growth rate", "label": " example\n"}, "con-119": {"from": "hash system", "to": "hash function", "label": " uses"}, "con-120": {"from": "hash system", "to": "bucket hashing", "label": " type\n"}, "con-121": {"from": "hash system", "to": "closed hash system", "label": " type\n"}, "con-122": {"from": "hash system", "to": "open hash system", "label": " type\n"}, "con-123": {"from": "hashing", "to": "hash table", "label": " has"}, "con-124": {"from": "hashing", "to": "hash function", "label": " has\n"}, "con-125": {"from": "hashing", "to": "collision resolution policy", "label": " has\n"}, "con-126": {"from": "heap", "to": "complete binary tree", "label": " is"}, "con-127": {"from": "heap", "to": "priority queue", "label": " used in\n"}, "con-128": {"from": "heap", "to": "max heap", "label": " example\n"}, "con-129": {"from": "heap", "to": "min heap", "label": " example\n"}, "con-130": {"from": "heapsort", "to": "replacement selection", "label": " variant"}, "con-131": {"from": "heapsort", "to": "heap", "label": " concept of\n"}, "con-132": {"from": "inherit", "to": "base class", "label": " has"}, "con-133": {"from": "inherit", "to": "subclass", "label": " has\n"}, "con-134": {"from": "intermediate code generation", "to": "Parse tree", "label": " walks through"}, "con-135": {"from": "intermediate code generation", "to": "intermediate code", "label": " produces\n"}, "con-136": {"from": "kd tree", "to": "discriminator", "label": " uses"}, "con-137": {"from": "key", "to": "key space", "label": " has"}, "con-138": {"from": "key sort", "to": "key", "label": " uses"}, "con-139": {"from": "key-space decomposition", "to": "object-space decomposition", "label": " type"}, "con-140": {"from": "key-space decomposition", "to": "image-space decomposition", "label": " type\n"}, "con-141": {"from": "Kruskal's algorithm", "to": "UNION/FIND", "label": " uses"}, "con-142": {"from": "lexical analysis", "to": "interpreter", "label": " is"}, "con-143": {"from": "list", "to": "array-based list", "label": " implements"}, "con-144": {"from": "list", "to": "linked list", "label": " implements\n"}, "con-145": {"from": "local variable", "to": "automatic variable", "label": " synonym"}, "con-146": {"from": "local variable", "to": "stack variable", "label": " synonym\n"}, "con-147": {"from": "locality of reference", "to": "80/20 rule", "label": " example use"}, "con-148": {"from": "lower bounds proof", "to": "adversary argument", "label": " example"}, "con-149": {"from": "lower bounds proof", "to": "sorting lower bound", "label": " example\n"}, "con-150": {"from": "lower bounds proof", "to": "search lower bound", "label": " example\n"}, "con-151": {"from": "member", "to": "element", "label": " synonym"}, "con-152": {"from": "memory hierarchy", "to": "primary storage", "label": " storage type"}, "con-153": {"from": "memory hierarchy", "to": "secondary storage", "label": " storage type\n"}, "con-154": {"from": "memory manager", "to": "buddy method", "label": " example"}, "con-155": {"from": "minimal-cost spanning tree", "to": "Kruskal's algorithm", "label": " algorithms"}, "con-156": {"from": "minimal-cost spanning tree", "to": "Prim's algorithm", "label": " algorithms\n"}, "con-157": {"from": "minimal-cost spanning tree", "to": "MCST", "label": " abbreviation\n"}, "con-158": {"from": "minimal-cost spanning tree", "to": "MST", "label": " abbreviation\n"}, "con-159": {"from": "minimal-cost spanning tree", "to": "cycle", "label": " never have\n"}, "con-160": {"from": "minimal-cost spanning tree", "to": "tree", "label": " is a\n"}, "con-161": {"from": "modulus", "to": "mod", "label": " abbreviation"}, "con-162": {"from": "multi-dimensional search structure", "to": "multi-dimensional search key", "label": " uses"}, "con-163": {"from": "multilist", "to": "bag", "label": " synonym"}, "con-164": {"from": "neighbor", "to": "adjacent", "label": " is"}, "con-165": {"from": "neighbor", "to": "graph", "label": " context\n"}, "con-166": {"from": "node", "to": "neighbor", "label": " linked to"}, "con-167": {"from": "node", "to": "dynamic allocation", "label": " created by\n"}, "con-168": {"from": "node", "to": "depth", "label": " property\n"}, "con-169": {"from": "NP-Complete", "to": "NP", "label": " is"}, "con-170": {"from": "NP-Complete", "to": "NP-hard", "label": " is\n"}, "con-171": {"from": "NP-Complete", "to": "clique", "label": " example problem\n"}, "con-172": {"from": "non-deterministic polynomial time algorithm", "to": "NP", "label": " abbreviation"}, "con-173": {"from": "non-deterministic polynomial time algorithm", "to": "non-deterministic choice", "label": " operation\n"}, "con-174": {"from": "object", "to": "class", "label": " instance of"}, "con-175": {"from": "object-oriented programming paradigm", "to": "cohesion", "label": " key concept"}, "con-176": {"from": "object-oriented programming paradigm", "to": "inherit", "label": " principle\n"}, "con-177": {"from": "object-oriented programming paradigm", "to": "encapsulation", "label": " principle\n"}, "con-178": {"from": "object-oriented programming paradigm", "to": "polymorphism", "label": " principle\n"}, "con-179": {"from": "object-oriented programming paradigm", "to": "abstraction", "label": " principle\n"}, "con-180": {"from": "object-oriented programming paradigm", "to": "object", "label": " consists of\n"}, "con-181": {"from": "order of growth", "to": "growth rate", "label": " synonym"}, "con-182": {"from": "order of growth", "to": "lower bound", "label": " type\n"}, "con-183": {"from": "order of growth", "to": "upper bound", "label": " type\n"}, "con-184": {"from": "parser", "to": "compiler", "label": " part of"}, "con-185": {"from": "parser", "to": "parse tree", "label": " build\n"}, "con-186": {"from": "path", "to": "tree", "label": " In"}, "con-187": {"from": "path", "to": "vertex", "label": " sequence of\n"}, "con-188": {"from": "pointer", "to": "variable", "label": " is a"}, "con-189": {"from": "pointer", "to": "address", "label": " value\n"}, "con-190": {"from": "pointer", "to": "binary tree", "label": " used in\n"}, "con-191": {"from": "pointer", "to": "linked list", "label": " used in\n"}, "con-192": {"from": "pointer", "to": "pointee", "label": " point to\n"}, "con-193": {"from": "pointer", "to": "shallow copy", "label": " default copy\n"}, "con-194": {"from": "pointer", "to": "dereference", "label": " get pointee value\n"}, "con-195": {"from": "pointer", "to": "initialization", "label": " requires\n"}, "con-196": {"from": "polymorphism", "to": "run-time polymorphism", "label": " form"}, "con-197": {"from": "polymorphism", "to": "compile-time polymorphism", "label": " form\n"}, "con-198": {"from": "pointee", "to": "array", "label": " example"}, "con-199": {"from": "pointee", "to": "object", "label": " example\n"}, "con-200": {"from": "primary storage", "to": "RAM", "label": " example"}, "con-201": {"from": "primary storage", "to": "main memory", "label": " synonym\n"}, "con-202": {"from": "Prim's algorithm", "to": "greedy algorithm", "label": " is a"}, "con-203": {"from": "Prim's algorithm", "to": "Dijkstra's algorith", "label": " identical to\n"}, "con-204": {"from": "proof", "to": "lower bounds proof", "label": " example"}, "con-205": {"from": "proof", "to": "NP-Completeness proof", "label": " example\n"}, "con-206": {"from": "proof", "to": "proof by contradiction", "label": " type\n"}, "con-207": {"from": "proof", "to": "proof by induction", "label": " type\n"}, "con-208": {"from": "queue", "to": "dequeue", "label": " operations"}, "con-209": {"from": "queue", "to": "enqueue", "label": " operations\n"}, "con-210": {"from": "RAM", "to": "random access memory", "label": " abbreviation for"}, "con-211": {"from": "recursion", "to": "recurrence relation", "label": " expressed as"}, "con-212": {"from": "recursion", "to": "recursive function", "label": " implemented in\n"}, "con-213": {"from": "recursive function", "to": "base case", "label": " includes"}, "con-214": {"from": "recursive function", "to": "recursive call", "label": " includes\n"}, "con-215": {"from": "recursive function", "to": "binary search", "label": " example\n"}, "con-216": {"from": "reference", "to": "pointer", "label": " similar to"}, "con-217": {"from": "reference", "to": "bad reference", "label": " if not initialized\n"}, "con-218": {"from": "run-time polymorphism", "to": "Overriding", "label": " Known as"}, "con-219": {"from": "runtime stack", "to": "activation record", "label": " composed of"}, "con-220": {"from": "scanner", "to": "compiler", "label": " part of"}, "con-221": {"from": "scanner", "to": "lexical analysis", "label": " responsible for\n"}, "con-222": {"from": "search tree", "to": "Binary Search Tree", "label": " example"}, "con-223": {"from": "search tree", "to": "2-3 tree", "label": " example\n"}, "con-224": {"from": "search tree", "to": "B-tree", "label": " example\n"}, "con-225": {"from": "search tree", "to": "search trie", "label": " example\n"}, "con-226": {"from": "search trie", "to": "alphabet trie", "label": " example"}, "con-227": {"from": "search trie", "to": "binary trie", "label": " example\n"}, "con-228": {"from": "secondary storage", "to": "disk drive", "label": " example"}, "con-229": {"from": "self-organizing list", "to": "move-to-front", "label": " heuristic"}, "con-230": {"from": "self-organizing list", "to": "transpose", "label": " heuristic\n"}, "con-231": {"from": "serialization", "to": "deserialization", "label": " reversed by"}, "con-232": {"from": "serialization", "to": "sequential tree representation", "label": " example\n"}, "con-233": {"from": "simple type", "to": "boolean", "label": " example of"}, "con-234": {"from": "simple type", "to": "integer", "label": " example of\n"}, "con-235": {"from": "singly linked list", "to": "one-way list", "label": " synonym"}, "con-236": {"from": "spatial data structure", "to": "bintree", "label": " example"}, "con-237": {"from": "spatial data structure", "to": "kd tree", "label": " example\n"}, "con-238": {"from": "spatial data structure", "to": "PR quadtree", "label": " example\n"}, "con-239": {"from": "Splay Tree", "to": "splaying", "label": " operation"}, "con-240": {"from": "stack", "to": "push", "label": " operations"}, "con-241": {"from": "stack", "to": "pop", "label": " operations\n"}, "con-242": {"from": "subgraph", "to": "clique", "label": " example"}, "con-243": {"from": "syntax analysis", "to": "parse tree", "label": " generates"}, "con-244": {"from": "syntax analysis", "to": "tokens", "label": " accepts\n"}, "con-245": {"from": "trie", "to": "alphebet trie", "label": " example"}, "con-246": {"from": "trie", "to": "binary trie", "label": " example\n"}, "con-247": {"from": "trie", "to": "search trie", "label": " example\n"}, "con-248": {"from": "variable-length coding", "to": "Huffman codes", "label": " example"}, "con-249": {"from": "variable-length coding", "to": "fixed-length coding", "label": " contrast to\n"}, "con-250": {"from": "vector", "to": "sequence", "label": " synonym"}, "con-251": {"from": "vector", "to": "dynamic array", "label": " synonym\n"}, "con-252": {"from": "vertex", "to": "node", "label": " synonym"}}}