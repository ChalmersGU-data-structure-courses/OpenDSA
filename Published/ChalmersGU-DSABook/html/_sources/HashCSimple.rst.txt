.. raw:: html

   <script>ODSA.SETTINGS.MODULE_SECTIONS = ['hash-tables-without-bins', 'collision-resolution', 'implementing-methods-of-the-hash-map', 'linear-probing', 'the-problem-with-linear-probing'];</script>

.. _HashCSimple:


.. raw:: html

   <script>ODSA.SETTINGS.DISP_MOD_COMP = true;ODSA.SETTINGS.MODULE_NAME = "HashCSimple";ODSA.SETTINGS.MODULE_LONG_NAME = "Open Addressing";ODSA.SETTINGS.MODULE_CHAPTER = "Hash Tables"; ODSA.SETTINGS.BUILD_DATE = "2021-11-08 09:26:08"; ODSA.SETTINGS.BUILD_CMAP = true;JSAV_OPTIONS['lang']='en';JSAV_EXERCISE_OPTIONS['code']='pseudo';</script>


.. |--| unicode:: U+2013   .. en dash
.. |---| unicode:: U+2014  .. em dash, trimming surrounding whitespace
   :trim:



.. odsalink:: AV/Hashing/linProbeCON.css
.. This file is part of the OpenDSA eTextbook project. See
.. http://opendsa.org for more details.
.. Copyright (c) 2012-2020 by the OpenDSA Project Contributors, and
.. distributed under an MIT open source license.

.. avmetadata::
   :author: Cliff Shaffer, Peter Ljungl√∂f
   :requires: open hashing
   :satisfies: collision resolution
   :topic: Hashing

.. index:: ! collision resolution

Open Addressing
===============

Hash tables without bins
-------------------------

We now turn to the most commonly used form of hashing:
:term:`open addressing` (also called :term:`closed hashing <closed hash system>`)
with no bucketing, and a :term:`collision resolution policy`
that can potentially use any slot in the hash table.

Compared to :ref:`separate chaining  <OpenHash>`,
we will now have room for exactly one entry in each table cell.
If we want to implement a **HashMap** (not a HashSet), we then need to be
able to put both a key and a value in the same table cell.
For this we need a class of key-value pairs.

.. codeinclude:: ChalmersGU/KVPair
   :tag: KVPair

Now we can initialise our open addressing hash map.
In addition to the array of key-value pairs, we need a counter of the size,
and the number of deleted cells (which is explained in
:ref:`later in this chapter <HashDel>`).

.. codeinclude:: ChalmersGU/OpenAddressingHashMap
   :tag: Header

We use the same constants as for the separate chaining map, but the values
are different. Most importantly, the ``MaxLoadFactor`` must be smaller than 1,
since there can only be one value per array slot.

.. codeinclude:: ChalmersGU/OpenAddressingHashMap
   :tag: Constants


Collision Resolution
--------------------

The goal of :term:`collision resolution` is to find
a free slot in the hash table when the "home position" for the record is
already occupied.
We can view any collision resolution method as generating a sequence
of hash table slots that can potentially hold the record.
The first slot in the sequence will be the home position for the key.
If the home position is occupied, then the collision resolution policy
goes to the next slot in the sequence.
If this is occupied as well, then another slot must be found, and
so on.
This sequence of slots is known as the
:term:`probe sequence`, and it is generated by some
:term:`probe function` that we will call **p** (or ``probe`` in the source code).
Probing works as follows.

.. codeinclude:: ChalmersGU/OpenAddressingHashMap
   :tag: HashIndex
  
The method ``hashAndProbe`` first calculates the *home slot*,
which is the hash code compressed to an index in the internal hash array.
Then it uses the probe function
:math:`\textbf{p}(k, i)` to locate a free slot in the table.
Function **p** has two parameters, the key :math:`k` and a
count :math:`i` of where in the probe sequence we wish to be.
That is, to get the first position in the probe sequence
for key :math:`K`, we call :math:`\textbf{p}(K, 0)`.
For the next slot in the probe sequence, call :math:`\textbf{p}(K, 1)`,
then :math:`\textbf{p}(K, 2)`, etc.
If the key is already in the table, ``hashAndProbe`` returns the position of that entry,
otherwise it returns the position of the first unoccupied slot.

Note that the probe function returns an offset from the original home
position, rather than a slot in the hash table.
Thus, the ``for`` loop in ``hashAndProbe`` is computing positions
in the table at each iteration by adding the value returned from the
probe function to the home position.
The :math:`i` th call to **p** returns the :math:`i` th offset to be used.

Implementing methods of the hash map
------------------------------------

All main methods in the Map interface
(``put``, ``get`` and ``remove``)
use the same probing function **p** to get the same probe sequence.
In this way, a record not in its home position can be recovered.

An implementation for the ``get`` method is as follows.

.. codeinclude:: ChalmersGU/OpenAddressingHashMap
   :tag: Get

Searching and inserting both assume that at least
one slot on the probe sequence of every key will be empty.
Otherwise they will continue in an infinite loop on unsuccessful
searches.
Thus, the hash system should keep a count of the number of records stored,
and make sure to resize the array when it becomes too full.

Setting a value for a key into the hash map works like this.

.. codeinclude:: ChalmersGU/OpenAddressingHashMap
   :tag: Put

First we the next available slot for the given key.
If the slot is empty (``null``), we create a new ``KVPair``
with the key and value and insert it into the table,
and increase the map size.
otherwise we update the value of the current entry,
which doesn't change the size of the table.
Finally, we resize the table if the load factor becomes too large.

Deleting from an open addressing hash table is explained in
:ref:`a later module <HashDel>`.


Linear probing
----------------

The simplest approach to collsion resolution is simply to move down
the table from the home slot until a free slot is found.
This is known as :term:`linear probing`.
The probe function for simple linear probing is
:math:`\textbf{p}(K, i) = i`.
That is, the :math:`i` th offset on the probe sequence is just
:math:`i`,
meaning that the :math:`i` th step is simply to move down  :math:`i`
slots in the table.
Once the bottom of the table is reached, the probe sequence
wraps around to the beginning of the table (since the last step is to
mod the result to the table size).
Linear probing has the virtue that all slots in the table will be
candidates for inserting a new record before the probe sequence
returns to the home position.

.. inlineav:: linProbeCON1 ss
   :points: 0.0
   :required: False
   :threshold: 1.0
   :long_name: Linear Probing Slideshow 1
   :output: show

Can you see any reason why this might not be the best approach
to collision resolution?


The Problem with Linear Probing
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

While linear probing is probably
the first idea that comes to mind when considering collision
resolution policies, it is not the only one possible.
Probe function **p** allows us many options for how to do collision
resolution.
In fact, linear probing is one of the worst collision resolution
methods.
The main problem is illustrated by the next slideshow.

.. inlineav:: linProbeCON2 ss
   :points: 0.0
   :required: False
   :threshold: 1.0
   :long_name: Linear Probing Slideshow 2
   :output: show

Again, the ideal behavior for a collision resolution mechanism is that
each empty slot in the table will have equal probability of
receiving the next record inserted (assuming that every slot in the
table has equal probability of being hashed to initially).
This tendency of linear probing to cluster items together is known as
:term:`primary clustering`.
Small clusters tend to merge into big clusters, making the problem
worse.

The problem with primary clustering is that it leads to
long probe sequences, which increases execution time.
However, linear probing is still a very common probing method,
because it is so simple and can be implemented efficiently.

.. avembed:: Exercises/Hashing/HashLinearPPRO.html ka
   :module: HashCSimple
   :points: 1.0
   :required: True
   :threshold: 5
   :exer_opts: JXOP-debug=true&amp;JOP-lang=en&amp;JXOP-code=pseudo
   :long_name: Linear Probing Proficiency Exercise

.. odsascript:: AV/Hashing/linProbeCON1.js
.. odsascript:: AV/Hashing/linProbeCON2.js
